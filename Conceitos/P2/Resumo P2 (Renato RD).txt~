AÇÚCAR
========

O processo de construção de açúcar permite transformar uma sintaxe 
em outra:
            sintaxe A ----------------------> sintaxe B
                                               (core)

O primeiro exemplo que utilizamos para açúcar sintático foi:
        (let (var val) body) --> ((λ (var) body) val)

Mas assim como conseguimos criar regras de açúcar diretamente na 
linguagem açucarada, também poderíamos fazê-lo EM TEMPO DE INTERPRETAÇÃO
(on the fly).

No Racket, existe essa opção, por meio dos comando:
    (define-syntax macro regra)
                         ^^^^^- { syntax-rules
                                { syntax-case

Criaremos um "novo let". Para que o próprio Racket não se confunda, 
usaremos o nome "my-let" com números 1,2,... para eles.

(define-syntax my-let-1
    (syntax-rules () ; arg para definir associações locais às regras
        
        ; Lista de regras de tradução
        [(my-let-1 (var val) body) ((lambda (var) body) val)]
        
        ; Cada uma das regras trabalha como MACRO - nenhuma 
        ; modificação é criada e só se traduz de um para outro.
))

Podemos aceitar argumentos como listas de qualquer tamanho, usando
o símbolo "...". Ele funciona como os TEMPLATES VARIÁDICOS do C++ 
ou as funções com múltiplos argumentos do C:

                    ..----------------------------..-------------..
                    \/                            /\             /\
         Constroi 'n' pares (var val)       Pega 'n' vars  Pega 'n' vals
                _____________                 _________       ________
    [(my-let-2 [(var val) ...] body) ((lambda (var ...) body) val ...)]

O Dr. Racket tem a opção MACRO-STEPPER, que mostra qual o resultado das
EXPANSÕES DE MACROS criadas pelo define-syntax. Entretanto, nem sempre
o resultado pode ser o esperado, pois o Racket pode OTIMIZAR os
argumentos variádicos para seus próprios lambdas.

PROBLEMAS
-----------

Os macros são interessantes, mas podem gerar problemas parecidos com as
macros de C/C++: os erros não são checados quando definimos as novas
regras sintáticas. Por exemplo

* Racket                          | * C/C++
                                  | 
; Em vez de um símbolo para       | // Definição do Macro em C ou C++.
; argumento, colocamos um número  | // Não usamos paerênteses suficientes
(my-let-1 (1 5) 1)                | #define SQUARE(X) X*X
                                  | 
; A tradução ficaria:             | // A expressão:
((λ (1) 1) 5)                     | SQUARE(2+2);
                                  | 
; O erro, porém seria:            | // Seria traduzida em:
    lambda: not an identifier,    | 2+2*2+2
    identifier with default, or   | 
    keyword in: 1                 | // O resultado 8 é diferente de 16

SYNTAX-CASE
=============

Poderemos usar,agora, o SYNTAX-CASE, mais geral, para que façamos
regras válidas.

Ele receberá uma lista de pares [A, B], com:
* A, o padrão a ser identificado na linguagem;
* B, cujo VALOR INTERPRETADO será associado a A;

O fato dele associar o VALOR INTERPRETADO da expressão B pode ser 
ruim, caso queiramos apenas devolver uma expressão. Para isso, usaremos
um truque relacionado ao operador #' (à frente).

; Associamos o nome 'my-let-3' a um símbolo x. O 'x' é um auxiliar, 
; que permite chamar RECURSIVAMENTE a estrutura do define-syntax.
; Isso é importante porque o símbolo "my-let-3" poderia ser utilizado
; dentro do pattern ou valor. Temos, então, este auxiliar.
(define-syntax (my-let-3 x)
    
    ; O 'x' de acima é passado para o syntax-case, como um 'this'.
    (syntax-case x ()
        [
         ; Padrão a ser identificado
         (my-let-3 (var val) body) 
         
         ; O símbolo #' serve para que o syntax-case devolva a 
         ; própria expressão, e não o resultado da execução dela.
         ; Em geral, para não executarmos, usamos apenas '. Porém,
         ; ' transforma uma expressão em s-expression. O syntax-case
         ; EXIGE que o argumento seja um PEDAÇO DE SINTAXE - e o
         ; operador #' é o que evita a execução e devolve um pedaço
         ; de sintaxe. O #' será necessário em todos os casos em que
         ; quisermos usar um pedaço do pattern, sem executá-lo (o que
         ; seria, inclusive, impossível, pois ele não existe ainda
         ; dentro da macro).
         #'((lambda (var) body) val)
        ]
))

O my-let-3 faz exatamente o mesmo que o my-let-2, mas usa o syntax-case.
Entretanto, o syntax-case tem uma segunda forma que pode ser útil.
Ele não receberá mais pares [A B], em que associa-se o padrão A 
ao valor (B). Teremos como argumentos trincas [A P B], com:
* A, o padrão;
* B, cujo valor interpretado será associado a A;
* P (predicado), as RESTRIÇõES a serem avaliadas.

(define-syntax (my-let-4 x)
    (syntax-case x ()
        [
         ; Padrão a ser identificado 
         (my-let-4 (var val) body) 
        
         ; Predicado a ser avaliado
         ; Se 'var' não for identificador, dará erro.
         (identifier? #'var)
         
         ; Igual ao caso do my-let-3
         #'((lambda (var) body) val)
        ]
))

SYNTAX-CASE RECURSIVO
=======================

Vejamos um exemplo de syntax-case RECURSIVO. Para isso, vamos
implementar uma forma de OR usando IF's recursivamente:

(define-syntax (my-or-1 x)
  (syntax-case x ()
    ; Usamos um template variádico
    [(my-or-1 e0 e1 ...)
      #'(if e0
            e0
            (my-or-1 e1 ...))
            ; Reusamos o template variádico com menos 1 argumento.
            ; Como a lista é finita, uma hora a recursão para.
))

Esse comando dá um erro, porque no final não teremos mais como expandir
o my-or-1. Consideremos o exemplo:
                            (my-or-1 #f #t)

O resultado da expansão seria:
(if #f #f (my-or-1 #t))
           ^^^^^^^-- (if #t #t (my-or-1))
                                ^^^^^^^-- Sem argumentos, é desconhecido

Precisamos adicionar uma nova regra ao syntax-case, para quando ele 
tem 0 argumentos.

(define-syntax (my-or-2 x)
  (syntax-case x ()
    [(my-or-2) 
      #'#f]
    [(my-or-2 e0 e1 ...)
      #'(if e0
            e0
            (my-or-2 e1 ...))
))

Poderíamos adicionar um passo a mais, com apenas um argumento. O
anterior já funciona, mas poderíamos adicionar um caso extra: apenas
um argumento, em que o devolvemos.

(define-syntax (my-or-3 x)
  (syntax-case x ()
    [(my-or-3) 
      #'#f]
    [(my-or-3 e0) 
      #'e0]
    [(my-or-3 e0 e1 ...)
      #'(if e0
            e0
            (my-or-3 e1 ...))
))

Nesse caso, naturalmente, nunca entraremos no caso base my-or-3 vazio.
Poderíamos retirá-lo, para dar erro de sintaxe, OU devolver falso nos
casos errados.

Consideremos agora o seguinte exemplo:
(let ([blah #f])
(my-or-3
    (begin ((set! blah (not blah)) blah)
    #f)
)

O resultado expandido será:
(if (begin ((set! blah (not blah)) blah))
    (begin ((set! blah (not blah)) blah))
    (my-or-4 #f))

O valor devolvido seria #f (errado!).

Estamos DUPLICANDO código. Esse é um dos grandes problemas de macros:
replicação desnecessária. E isso ocorre por causa do excesso de lazyness
do código.

Para resolvermos, podemos calcular primeiro, e associar o valor
calculado a um símbolo:

(define-syntax (my-or-4 x)
  (syntax-case x ()
    [(my-or-4) 
      #'#f]
    [(my-or-4 e) 
      #'e]
    [(my-or-4 e0 e1 ...)
      #'(let ([v e0]) ; salva a avaliação em v
          (if v
              v
              (my-or-4 e1 ...))
))

Ainda assim, temos dois potenciais problemas:
* O cálculo do primeiro e0 poderia causar uma mudança de estado - e esta
  não seria passada para o corpo do if. A mudança de estado já estaria
  feita antes, e o resultado poderia ser diferente. Uma outra
  consequência da passagem de estado. O caso do begin acima não era o
  desejado. Porém, se ele fosse, não seria coberto.

* O e0 poderia estar em um environment diferente, e o seu valor estaria
  de forma diferente. Por exemplo:
    
    (let ([e0 #t]) (my-or-4 #f e0))
    
    A expansão seria:
    (let ([v #f])
        if(#f) #f
            (my-or-4 #f))
    
    Nesse caso, estamos CONFUNDINDO o environment externo com o
    environment interno. O valor de e0 usado acaba sendo o de dentro,
    e não o passado de fora.
    
    Bons sistemas de macro não confundem isso, pois usam tabelas
    separadas para valores de argumentos e definições internas de
    símbolos. Essas são chamadas as MACROS HIGIÊNICAS.

=================================================================

MACROS
========

Na aula passada, vimos uma "confusão" dos macros por causa do
environment. A diferenciação entre ambos pode ser desejável para que
possamos fazer definições de macros RECURSIVAS ou com AUTORREFERÊNCIA.

Os macros que evitam esse problema é um MACRO HIGIÊNICO, mas teria esse 
novo problema. A implementação que daria este problema seria:

; Definição de um objeto com autorreferência
; usando a criação via macros.
(define os-1
    (object/self-1
        
        ; Este self dará um ERRO. O processador de macros do Racket
        ; é higiênico. Logo, dentro do macro ele olhará se esse self
        ; foi definido NESTE AMBIENTE. Ele não foi: logo, aparecerá o
        ; erro do self não ser definido.
        [first  (x) (msg self 'second (+ x 1))]
        
        [second (x) (+ x 1)]
))

; Como fazemos isso com macros agora?
(define-syntax object/self-1
  (syntax-rules ()
    [(object [mtd-name (var) val] ...)
        
      ; Primeiro, associamos self com um símbolo qualquer. 
      ; No caso, é um lambda que imprime que está vazio.
      (let ([self (lambda (msg-name)
                    (lambda (x) (error 'object "nothing here")))])
          
          ; Reassocia self com o lambda seletor dos métodos
          (begin 
            (set! self
                  (lambda (msg)
                    (case msg
                      ; O macro cria um lambda usando o nome do
                      ; método, a variável do lambda e o corpo.
                      ; Como pode haver vários métodos, estamos 
                      ; fazendo de forma recursiva
                      [(mtd-name) (lambda (var) val)]
                      ...)))
          self)
      ) ;end let
]))

; O resultado do código expandido seria:
(let ([self 'dummy])
  (begin 
    (set! self
      (λ (msg)
        (case msg
          [(first  (λ (x) (msg self)) )]
          [(second (λ (x) (+ x 1))    )]
)))))

O self do os-1 é marcarado pelo self do object/self-1 quando não deveria.
Uma solução é "arrastar" o primeiro self para dentro da definição,
pré-associando o self:

; Por que esse self não dá problemas quando passado como argumento?
(define os-2
    (object/self-2 self ; O nome do próprio argumento deve ser passado
                        ; como primeiro parâmetro.
                   [first  (x) (msg self 'second (+ x 1))]
                   [second (x) (+ x 1)]))

(define-syntax object/self-2
  (syntax-rules ()
    [(object self [mtd-name (var) val] ...)
        
      ; Primeiro, associamos self com um símbolo qualquer. 
      ; No caso, é um lambda que imprime que está vazio.
      (let ([self (lambda (msg-name)
                    (lambda (x) (error 'object "nothing here")))])
          
          ; Reassocia self com o lambda seletor dos métodos. Agora,
          ; este é o self externo, e estamos afetando a tabela dos 
          ; argumentos.
          (begin 
            (set! self
                  (lambda (msg)
                    (case msg
                      [(mtd-name) (lambda (var) val)]
                      ...)))
            self)
      ) ;end let
]))

(resumo) Mas nem sempre seria desejável passar 'self' como argumento.
Como evitar isso? Poderíamos usar um recurso adicional, suportado pelo
Racket, que permite associar um símbolo DENTRO DA SINTAXE com um DE FORA
DA SINTAXE.  Dessa maneira, uma mudança de estado dentro da macro altera
o espaço das variáveis passadas como argumento para a macro. Assim,
conseguiríamos sobrescrever o self (o que não acontecia na 1ª forma,
pois o self estava em outra tabela de símbolos).

(apostila) O chato disso é que o usuário do macro precisa passar o nome
na definição.
Uma forma de contornar o problema é usar o with-syntax, que é essencialmente
um let para variáveis de sintaxe. Precisamos também poder transformar uma
componente da expressão em sintaxe, o que é feito por datum->syntax.

(define os-3
    (object/self-3
        [first  (x) (msg self 'second (+ x 1))]
        [second (x) (+ x 1)]
))

(define-syntax (object/self-3 x)
  (syntax-case x ()
    [(object [mtd-name (var) val] ...)
      ; associa sintaticamente self com o self passado no argumento
      (with-syntax ([self (datum->syntax x 'self)])
        #'(let ([self (lambda (msg-name)
                        (lambda (v) (error 'object "nothing here")))])
            (begin 
              (set! self
                (lambda (msg-name)
                  (case msg-name
                    [(mtd-name) (lambda (var) val)]
                    ...
              )))
              self
            )
          ) ; let
      ) ; with-syntax
    ] ; definição de objeto
))

Enquanto macros facilitam bastante a construção de linguagens e têm
inúmeras aplicações em outras ferramentas, a inserção direta na
linguagem central é um princípio muito mais eficiente.
Acontece que os compiladores conseguem reconhecer expressões e
otimizá-las. No caso do let, a presença de um lambda que devolve um
lambda que por sua vez deve ser imediatamente aplicado, pode ser
facilmente identificado e trocado por uma extensão do ambiente.

=================================================================

ESTRUTURA CLIENTE SERVIDOR
============================

Controle se refere a controle de fluxo, basicamente desvios e desvios
condicionais. Nos casos extremos, existem coisas parecidas como longjmp
e exceptions. Transferências de controle de uma instrução para seguinte
sempre ocorre, o caso interessante é quando a transferência não é local.
Controle, neste sentido, não aumenta o poder computacional, apenas a expressividade.

Web
O controle em aplicativos distribuídos é particularmente interessante,
pois exite uma dependência grande no protocolo. O http merece estudo à parte.
Considere um servidor web que precisa interagir com o usuário. Normalmente,
um serviço web envia conteúdo estático (páginas ou arquivos), não há como
receber informações. Isto faz sentido, pois o número de usuários é potencialmente
infinito e nem todos completam as tarefas. Como não é possível determinar se a
computação acabou, o protocolo não mantém estado.
Um programa que pergunta 2 números e apresenta sua soma é bastante simples se
tivermos todo o contexto (e estado) disponível:

(define (read-number [prompt : string]) : number
    (begin
        (display prompt)             ; Mostra o prompt
        (let ([v (read)])            ; Lê da stdin e associa a v
            (if (s-exp-number? v)    ; Testa se é número
                (s-exp->number v)    ; Converte para número
                (read-number prompt) ; Se não funcionar, lê outro
                                     ; número
))))

(display 
    (+ (read-number "Fist number")
       (read-number "Second number"))
)

Se estivéssemos numa arquitetura cliente-servidor, este programa simples
de somar NÃO FUNCIONARIA. Você pediria o programa, o servidor enviaria a
pergunta "First number" e, então, acabaria a conexão.

CLIENTE-SERVIDOR COM MEMÓRIA
------------------------------

Precisamos quebrar o programa em DUAS PARTES: o primeiro pedido do
número (requisição 1), e depois executar o pedido do segundo número
(requisição 2). Até termos o segundo número, precisamos GUARDAR o 
primeiro deles.

Uma função que quebrasse poderia ser:

(lambda (v1)
  (display
    (+ v1
      (read-number "Second number"))))

Guardamos v1 no environment do lambda e depois esperamos pelo segundo
número aparecer.

CLIENTE-SERVIDOR SEM MEMÓRIA
------------------------------

Mas essa solução usa memória. Se tivéssemos vários usuários, poderíamos
ter muitos dados armazenados. No pior caso, isso se tornaria um ataque
DDoS (Denial of Service), pois exauriríamos o recurso do servidor.

A comunicação entre cliente e servidor é feita por common gateway interface (CGI),
os famosos formulários (forms) presentes no HTML. Um formulário permite
a entrada de diversos tipos de dados e seu envio por meio de uma action,
associada a um botão especial (submit). Ainda assim, o servidor não tem
como relacionar a solicitação recebida com a anterior.
Uma forma de resolver isso é usar uma tabela para armazenar resultados,
associando uma entrada para cada iteração. Assim, cada resposta a uma
requisição inclui a posição da tabela que contém os dados anteriores.
A tabela pode ser um hash e as iterações podem ser numeradas automaticamente,
com labels sucessivos:

Uma boa solução para contornarmos isso será criar uma ação que se
interrompe, enquanto aguarda pelas respostas dos usuários. Para cada
solicitação teremos um id único. Enviamos para o usuário um formulário
que contém o id da ação a ser realizada. Quando ele enviar os dados, o 
servidor executará a ação.

; retorna o próximo label disponível
(define new-label
  (let ([n (box 0)])
    (lambda ()
      (begin
        (set-box! n (+ 1 (unbox n)))
        (unbox n)))))

; O label para os processos serão números.
; A tabela será um hash vazio
(define-type-alias label number)
(define table (make-hash empty)

Precisamos de uma versão especial do read-number, que armazena na tabela
o que deve ser feito quanto (e se) o resultado chegar. Como ela irá parar
na primeira parte do programa, chamaremos de read-number/suspend. Uma
segunda função, resume, retoma a execução de onde parou.

; A função read-number/suspend apenas pega uma ação "rest" e a carrega
; na tabela de requisições
(define (read-number/suspend [prompt : string] rest)
  (let ([g (new-label)]) ; new-label é uma simples função contadora
    (begin
      (hash-set! table g rest)
      (display prompt)
      (display " To enter it, use the action field label ")
      (display g))))

; Esta ação é a "resposta", que envia o dado solicitado para o servidor.
; Na analogia web, esta seria uma página com FORMULÁRIO, a ser submetido
; ao servidor. Na resposta, teríamos o ACTION-FIELD, o label do hash que
; marca ONDE ESTÁ A AÇÃO A SER EXECUTADA.
(define (resume [g : label] [n : number])
  ((sum-v (hash-ref table g)) n))

Temos os dois passos da chamada web, read-number/suspend faz a primeira
e resume é o tratamento da ação.

========= TODO O PEDAÇO ABAIXO É PARTE DO RESUMO E NÃO DA APOSTILA ========= 

; A ação usando o read-number com suspensão fica:
(read-number/suspend 
  "First number"
  (lambda (v1)
     (display
       (+ v1
         (read-number "Second number"))))
)

; Para um esquema cliente-servidor mais robusto (no caso, que lesse os 
; dois números via este sistema), precisaríamos usar duas solicitações.

A representação das solicitações ficaria:

            Servidor             |              Cliente
=================================|====================================
                                 |            
   . read-number/suspend --------:----- label: 05
   :                             |      form: Mande valor
   :                             |            
   :   table                     |      resume 05 42
   : .----.--------------.       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   '>| 05 | rest         | <-----:-----------'
     |    |  |           |       |            
     |    |  |           |       |            
     '----'--|-----------'       |            
             ^                   |
         read-number             |

ESQUEMA CLIENTE-SERVIDOR COMPLETO
-----------------------------------

Há um problema: o lambda solicitando o v2 pede no servidor (o que não
é realista). Para resolver, basta colocarmos uma solicitação dentro da
outra:

(read-number/suspend 
  "First number"
  (lambda (v1)
    (read-number/suspend 
      "Second number"
        (lambda (v2)
          (display
            (+ v1 v2)
)))))

            Servidor             |              Cliente
=================================|====================================
                                 |            
 ..- read-number/suspend    -----:----- label: 05
 : .-'                 ^    |    |      form: Mande valor
 : :                   |    |    |            
 : :   table           |    |    |      resume 05 42
 : : .----.------------|-.  |    |           |
 : : |    |            | |  |    |           |
 : : |    |  sum       | |  '----:-----------:------ resume 03 0
 : : |    |   ^        | |       |           |            |
 : '>| 03 | rest2      | | <-----:-----------:------------'
 :   |    |            | |       |           |
 '-->| 05 | rest1 -----' | <-----:-----------'
     |    |              |       |            
     |    |              |       |            
     '----'--------------'       |            
                                 |

=================================================================

ARQUITETURA CLIENTE-SERVIDOR
==============================

Em geral, as formas que colocamos na arquitetura da última aula mantém o
ESTADO salvo dentro do hash dos labels. Porém, essa é uma forma, muitas
vezes, pouco eficiente: um usuário pode demorar para responder, ou pode
recarregar uma página web, resolicitar, etc.

Duas soluções, que mantém o estado fora do servidor, são possíveis:
* Manter o estado na aplicação
    Usando variáveis escondidas, que não aparecem numa página web, é
    possível enviar dados e/ou ações pela rede. Este protocolo é SEM 
    ESTADO: o protocolo não muda de acordo com o que está sendo
    transferido. Ele apenas transfere informação de um ponto a outro.
    O estado está nas aplicações (ações feitas), não no protocolo. 
    Nesse caso, não temos uma tabela que armazena dados/ações. O que
    precisa ser feito é enviado dentro do protocolo.
    (Apostila)
    Uma solução é não manter a tabela indefinida, mas ter as funções
    prontas e pré-definidas. A requisição pode escolher apenas uma delas.
    Ainda assim, temos o problema do argumento, mas este pode ficar
    armazenado no cliente (cookies e campos ocultos).

* Manter o estado no cliente
    Usamos o conceito de "cookies". Arquivos disponíveis no navegador 
    do usuário e que um dado site pode editar. Ele o usa para guardar 
    as informações dentro do cliente no momento em que submete um
    formulário para o servidor. O servidor pode, então, usar estes dados
    SALVOS no cliente para continuar as ações.
    
    ; cookies
    (define cookie '-100)
    
    (define (read-number/suspend "\nFirst number (cookie)"
      (lambda (v1)
        (begin
          (set! cookie v1)
          (read-number/suspend "\nSecond number (cookie)"
                               (lambda (v2) (display (+ cookie v2)))
      )))
    ))

    Este é um exemplo de transimissão de informações chamado
    continuation passing style (CPS). Ele consiste, primariamente, de
    quebrar uma ação numa sequência de passos. Dado um passo i, ele 
    executa a computação correspondente a ele e depois envia o restante
    da operação i+1 para ser executada depois.

=================================================================

CONTINUATION PASSING STYLE
============================

(apostila) Esta estratégia de passar a informação para que a computação
possa ser completada (ou continuada) é chamado de estilo de passagem de
continuação (continuation passing style - CPS), ou simplesmente "continuações".
Para tornar mais intuitivo, pense que qualquer computação é um (lambda)
que recebe como argumento o procedimento que deve ser aplicado ao resultado
da computação que é feita em seu corpo. Este argumento é a continuação.
O método é transformar funções de um argumento (não todas, apenas as que
envolvem interação remota) em outra função com dois argumentos. O segundo
argumento é uma função que executa o resto do processamento: a continuação.

Este método de computação é o utilizado dentro do esquema
cliente-servidor (mesmo com suas várias formas de manter o estado). O
conceito chave é quebrar uma certa computação em uma série de passos
menores, em que vamos mantendo o "resto" da computação depois da
operação.

Ex:
    ; Toda expressão CONSTANTE deve ser quebrada na forma:
    ; * Constantes cte:
    ; (λ (resto) (resto cte) )
    
    - Original:
    (+ 2 2)
    
    - CPS:
    (
        (λ (resto) (resto 2))
        (λ (x) (+ x 2))
    )

Ex:
    ; Todo LAMBDA deve ser quebrada na forma:
    ; * Lambdas (λ (arg) (ação arg)):
    ; (λ (arg resto) (resto (ação arg)) )
    
    - Original:
    ((λ (a) (+ (* a 2) 5)) 2)
    
    - CPS:
    (
        ; Criamos um lambda com a computação mais interna, (* a 2)
        ; que é depois aplicada no "resto" da ação.
        (λ (a, resto) (resto (* a 2)))
        
        ; O argumento para este lambda são dois valores: o x e o resto.
        (2 (λ (x) (+ x 5)))
    )

Para cada tipo de estrutura, quebraríamos de forma diferentes. Essa é
uma forma de TRANSFORMAÇÃO, em que estamos modificando o programa SEM
alterar o resultado. A implementação poderia ser feita de duas formas:
* Açúcar : Usando macros para transformar as sentenças originais;
* Core   : Modificar o core para implementar esta forma.

Se pegássemos uma expressão, teríamos a transformação na forma:
e:    3 * (5 + 2) - 7 * 4
f(x): 3 * x - 7 * 4         e = f(5+2)
g(y): y - 7 * 4             e = g(f(5+2))
...                         ...

Estamos passando o resultado de uma ação para a próxima. Essa é a ideia
de PILHA DE EXECUÇÃO, como feita em Assembly. Cada ação devolve apenas
uma modificação de estado, e o estado é compartilhada pelas várias ações
necessárias para serem feitas.
