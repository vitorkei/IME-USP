RACKET

* Antes, em geral, teríamos a criação do programa como:
    
    Código fonte ----> Tokens -----> código
                 lexer        parser 

  Agora, faremos algo diferente:
    
    Código fonte ----> Tokens -----> árvore interna ------> código
                 lexer        parser                backend

  Teremos, agora, uma ÁRVORE, e ela será construída pelo parser 
  para que represente o código.
    
  Teríamos 3 notações que gerariam uma mesma árvore:
    3 * (10 + 4)   infixa               *
    3 10 4 + *     posfixa             / \
    (* 3 (+ 10 4)) prefixa            3   +
                                         / \
                                        10  4
  
  A terceira representação é a mais simples para que nós possamos 
  representar a estrutura natural da árvore - e ela é perfeitamente
  interpretável em Lisp, Scheme e Racket.

* Estrutura de Racket
    ÁTOMOS -> valores (42, "string", #t (verdadeiro), #f (falso))
    
    LISTAS -> 
        (a b c ..)  'a' pode ser uma função, e é indistinda a uma 
        (+ 2 3)     variável. Por esse motivo a linguagem é FUNCIONAL,
                    pois a função é tratada como uma variável comum.

* Toda lista é executada. Porém, em alguns casos, seria interessante
  se pudéssemos gerar uma LISTA SEM EXECUÇÃO (como um vetor). Neste
  caso, a sintaxe é:
                                '(a b c)

* Toda EXPRESSÃO começa com uma PROCEDURE (que pode ter quase 
  qualquer tipo de caractere, exceto alguns como parênteses).
        (* 3 2)                 -> válido
        (* 2 (+ 7 6 5 1 2)      -> válido
        ()                      -> inválido: procedimentos devem ter
                                             sempre operador
        '()                     -> válido: lista vazia

* Podemos definir um novo nome para uma variável, usando a 
  procedure 'define':
    > (define x 5)

* As listas são representações simplificadas (abreviações) de 
  construções criadas por 'cons'. O 'cons' gera pares, que 
  são simplificadamente representados com um '.' entre eles.
  
    > (cons 5 6)
        (5 . 6)
    > (define x (cons 5 6))
    > (car x)
        5
    > (cdr x)
        6

* 'car' é sempre o primeiro elemento do par. 'cdr', o segundo. 
  Poderíamos ter, por exemplo:
    > (define x (cons '(1 2 3) '(4 5 6)))
    > (car x)
        '(1 2 3)
    > (cdr x)
        '(4 5 6)
    > (cdr (cdr x))
        '(5 6)
    > (cddr c)       @ Uma abreviação
        '(5 6)

* Uma lista é um conjunto de pares ligados, com o 'car' um elemento
  e o 'cdr' uma outra lista. Ex:
    > (car '(1 2))          
        1                   Uma lista é um par ordenado de um 
    > (cdr '(1 2))          elemento e uma sublista.
        '(2)                
    > (car (cons 1 2))      
        1                   Um cons é apenas um par de dois elementos
    > (car (cons 1 2))      (que podem ou não ser listas)
        2

* Podemos fazer comparações também:
    > (eq  1 '(1))
        Se o resultado da avaliação de ambos é igual
    > (eqv 1 '(1))
        Se a representação de ambas são equivalentes
    > (eq? 1 '(1))
        Se o texto é igual (como string)

* É possível trabalhar com números racionais (2/3) ou complexos (3+2i).

* Podemos criar funções anônimas (lambdas)
    > (λ (x) (* x x))
       ^  ^  ^^^^^^^-- Ação a ser executada
       |  '-- Argumento (átomo)
       '-- Será função anônima

* Usaremos a versão 'plai-typed', do livro principal da disciplina,
  para que possamos realizar vários usos.
* O Racket surgiu do Scheme, que veio de uma variação do Lisp.

* Em átomos, temos dois elementos principais:
    - Átomos: #\a (caracter); "Conceitos" (string); 
              15.3, 12, 3*1/2, 2+3i (números);
              λ (procedimentos);
    - Listas: São um conjunto de pares (cons):
              (a, b, c, d, e)
              (a . (b . (c . (d . (e . ()))))
               ^    ^    ^        ^^^^^^^^
               |    |    |        car  cdr
               |    |    |   ^^^^^^^^^^^^^
               |    |   car       cdr
               |    |   ^^^^^^^^^^^^^^^^^^^
               |   car            cdr
               |   ^^^^^^^^^^^^^^^^^^^^^^^^^
              car                 cdr 
            (cabeça)            (cauda)
    
    As listas são interessantes porque podem ser executadas. 
    Dessa maneira, qualquer coisa pode ser um identificador, 
    excetuando os nomes que seriam de átomos:
        (+, 1, 3) -> Faz a soma de 1 com 3
    
    Uma lista pode NÃO ser executada: para isso, podemos colocar
    um apóstrofe (') antes da lista. A execução é, então, adiada.

* Procedimentos
    Um procedimento pode ser criado com:
    (λ (lista de argumentos) execução)
    
    Podemos usar o procedimento 'apply' para passar um outro
    procedimento como ARGUMENTO, a ser aplicado em uma lista.
    
    Ou, simplificando: (define (nome lista_de_argumentos) (execução))
    
    É possível, até mesmo, criar 'fábricas de função':
        (define (faz* n) (λ (k) (* n k)))
        ((faz* 7) 6)
        > 42
        
    Chama-se de 'fechamento' (closure) uma função que carrega o 
    ambiente com ela. No exemplo acima, o valor de 'n', quando
    o procedimento é criado, cria-se uma ASSOCIAÇÃO entre o 'n'
    e a nova procedure. Esse é o 'ambiente' da variável, que 
    fica salvo. Em geral, este ambiente pode existir apenas em
    tempo de compilação.

=================================================================

PLAI-TYPED

Veremos agora uma linguagem TIPADA
#lang play-typed

Não temos mais 'car' ou 'cdr'. No lugar dela, usaremos a função
'list' para definir o tipo listas e 'first' para conseguir o 
'car' de um par e/ou uma lista. Ex:
    
    > (first (list 1 2 3))
    - number
    1

No play-typed, o apóstrofe tem tratamento diferente:
    > (+ 1 2)       @ É executado e recebemos o retorno
    - number
    3
    
    > '(+ 1 2)      @ Cria-se uma s-expression. Um tipo novo que
                    @ poderá ser interpretado.
    - s-expression
    '(+ 1 2)
    
    > (list 1 2)    @ Uma sequência de números, de certo tipo.
    - (listof number)
    '(1 2)

Para fazer o 'cast' entre s-expression e listas, precisamos usar
o operador 's-exp->list'.

Podemos fazer listas de listas:
    > (list (list 1 2) (list 4 5 6 7)) @ Listas de listas, como em Python
    - (listof (listof number))
    '((1 2) (4 5 6 7))

    > (list-ref (list 1 2 3 4 5 6) 3) @ Recupera um elemento de uma lista
    - number
    3

    > (vector 1 2 3) @ Vector: Tem tamanho FIXO, não pode ser MODIFICADO
                     @         e usualmente é mais rápido.
    - (vectorof number)
    '#(1 2 3)

Com o plai-typed, podemos declarar tipos com 'define'. Para
declarar EXPLICITAMENTE o tipo de um nome, colocamos de forma extra
um ':':
    > (define c "string")
    - string
    "string"
    
    > (define c : number 2)
    - number
    2
    
    > @ Já faz a verificação de tipagem previamente
    > (define c : number "string")
    - Erro

Outra forma de lista, que na realidade age como uma struct de C/C++,
é o 'value':
    > (values 9 8 "outro")
    - (number * number * string)
    '#(9 8 "outro")
    
    > @ Usando values para 'declarar' vários lugares.
    > (define-values (marca valor) (values "Prada" 3.50))
    > marca
    - string
    "Prada"
    > valor
    - number
    3.5
    
Fazendo funções:
    
    > (define (3* n) (* 3 n))
    > (3* 8)
    - number
    24
    
    > @ Define a função com TIPO DE ARGUMENTO e TIPO DE RETORNO
    > (define 3* [n : number]) : number (* 3 n)
    
    > ((λ ([x : number]) : number (+ x x)) 21)
    - number
    42
    
    > @ A sintaxe abaixo funciona como um 
    > (define mais2 : (number -> number) (λ(x) (+ x 2)))
    > (mais2 89)
    - number
    91
    > mais2
    - (number -> number)
    #procedure:...

Ainda no plai-typed, existe o fechamento (em que a função leva o 
contexto de algumas variáveis no seu ambiente com ela).

=================================================================

Core Language
================

Na aula passada, criamos uma primeira estrutura que mostrava como era
uma aritmética simples, somadora de números. O tipo ArithC tinha 3
possibilidades de construção: número (tipo primitivo, a base da
recursão) ou, recursivamente, um plusC/multC com duas ArithC.

(define-type ArithC                               multC
  [ numC  (n : number) ]                          /   \ 
  [ plusC (l : ArithC) (r : ArithC) ]         plusC   plusC
  [ multC (l : ArithC) (r : ArithC) ]         /   \   /   \
)                                           numC  numC numC numC

Mas como poderíamos adicionar uma SUBTRAÇÃO (-)? Poderíamos criar um
tipo diferente de Aritmética, que tivesse o tipo subtração:

(define-type ArithS                               (- a b)
  [ numS    (n : number) ]                           ↓
  [ plusS   (l : ArithS) (r : ArithS) ]           bminusS
  [ multS   (l : ArithS) (r : ArithS) ]            /   \   
  [ bminusS (l : ArithS) (r : ArithS) ]         numS   numS
)                                                   a     b

Mas como poderíamos converter para a árvore de ArithS para ArithC?
Poderíamos usar uma conversão:
                     (- a b) → (+ a (* -1 b))

A árvore gerada seria, então:
    
     plusC         | Chama-se o processo de introduzir a árvore mais 
     /   \         | complexa de AÇÚCAR SINTÁTICO. Entretanto, não é 
  numC   multC     | necessário ter que tornar a gramática do backend
   a     /   \     | mais complexa. Para retirar o açúcar sintático,
      numC   numC  | em geral cria-se uma função DESUGAR, que pega a 
       -1     b    | árvore primária e torna-a mais simples.
                   | 
                   | Um exemplo tradicional de açúcar sintático é um 
                   | FOR - que é convertido para um while.

Quando criamos uma linguagem, temos uma GRAMÁTICA, que define as regras
relacionadas à como a linguagem é lida pelo parser. A gramática segue 
uma sintaxe própria. Esta é convertida para uma sintaxe abstrata: a 
árvore com ArithS. Depois, para outra sintaxe abstrata, a que descreve
a árvore de ArithC. Poderíamos ter quantos níveis de gramática fosse
necessário.

A nossa função desugar ficaria:
(define (desugar [as : ArithS]) : ArithC
  (type-case ArithS as
    [ numS    (s)   (numC n) ]
    [ plusS   (l r) (plusC (desugar l) (desugar r)) ]
    [ multS   (l r) (plusC (desugar l) (desugar r)) ]
    [ bminusS (l r) (plusC (desugar l) 
                      (multC (numC -1) (desugar r)) ) ]
))

O interpretador é ainda o mesmo:
(define (interp [a : ArithC]) : number
  (type-case ArithC a
    [numC (n) n]
    [plusC (l r) (+ (interp l) (interp r))]
    [multC (l r) (* (interp l) (interp r))]

O parser para o ArithS será
(define (parse [s : s-expression]) : ArithS
  (cond
    [(s-exp-number? s) (numS (s-exp->number s))]
    [(s-exp-list? s)
      (let ([sl (s-exp->list s)])
        (case (s-exp->symbol (first sl))
          [(+) (plusS (parse (second sl)) (parse (third sl)))]
          [(*) (multS (parse (second sl)) (parse (third sl)))]
          ; agora temos o '-'
          [(-) (bminusS (parse (second sl)) (parse (third sl)))]
        [else (error 'parse "invali list input")]
    ))]
  [else (error 'parse "invalid input"')]
))

Para não precisarmos fazer conversões explícitas, podemos criar um
'interpS', que já aceita um ArithS como entrada e intepreta:
(define (interpS [a : ArithS]) (interp (desugar a)))

Como poderíamos, agora, criar um - unário? Também podemos usar um 
açucar sintático. Para isso, modifiquemos o ArithS:

(define-type ArithS
  [ numS    (n : number) ]                    
  [ plusS   (l : ArithS) (r : ArithS) ]       
  [ multS   (l : ArithS) (r : ArithS) ]       
  [ bminusS (l : ArithS) (r : ArithS) ]       
  [ uminusS (e : ArithS) ]                    
)

Podemos multiplicar qualquer expressão por -1. Teríamos, então, que
converter usando o desugar:

(define (desugar [as : ArithS]) : ArithC
  (type-case ArithS as
    [ numS    (s)   (numC n) ]
    [ plusS   (l r) (plusC (desugar l) (desugar r)) ]
    [ multS   (l r) (plusC (desugar l) (desugar r)) ]
    [ bminusS (l r) (plusC (desugar l) 
                      (multC (numC -1) (desugar r)) ) ]
    [ uminusS (e)   (desugar (bminusS (numS 0) e))
))

Essa solução é válida, mas ela tem um problema sutil: em uminusS, 
temos uma RECURSÃO. Precisamos garantir que a recursão pare sempre.
Em casos como um cálculo de fatorial (por exemplo), estamos 
reduzindo o problema sempre. Esse é um tipo de RECURSÃO ESTRUTURAL
(pegando, sempre, um problema menor). Entretanto, no caso acima,
quando usamos o bminusS, estamos aumentando nosso problema um 
pouco, dado que a chamada de 'desugar' foi sobre o bminusS, e não
sobre o e. Esse é um tipo de RECURSÃO GENERATIVA (chamada 
recursiva feita sobre algo um pouco maior), e tem o potencial de
não parar (não necessariamente, mas o potencial existe).

Para evitarmos isso, temos uma solução: trocar o uminusS

(define (desugar [as : ArithS]) : ArithC
  (type-case ArithS as
    [ numS    (s)   (numC n) ]
    [ plusS   (l r) (plusC (desugar l) (desugar r)) ]
    [ multS   (l r) (plusC (desugar l) (desugar r)) ]
    [ bminusS (l r) (plusC (desugar l) 
                      (multC (numC -1) (desugar r)) ) ]
    [ uminusS (e)   (multC (numC -1) (desugar e))
))

Temos, portanto, um desugar sobre 'e', reduzindo o problema. A 
recursão é ESTRUTURAL, e não GENERATIVA. O grande truque é 
fazer o produto por -1. Estamos sempre gerando sobre as primitivas,
criando açúcar sintático só sobre as primitivas, sem gerar açúcar
sobre açúcar.

O interpretador continua o mesmo, pois ainda temos o ArithC.

O parser, porém, agora precisará reconhecer o bminusS.
Como o '-' seria identificado como número, usaremos o ~ para ser
interpretado como '-'.

(define (parse [s : s-expression]) : ArithS
  (cond
    [(s-exp-number? s) (numS (s-exp->number s))]
    [(s-exp-list? s)
      (let ([sl (s-exp->list s)])
        (case (s-exp->symbol (first sl))
          [(+) (plusS (parse (second sl)) (parse (third sl)))]
          [(*) (multS (parse (second sl)) (parse (third sl)))]
          [(-) (bminusS (parse (second sl)) (parse (third sl)))]
          ; o '~' será o sinal negativo
          [(~) (uminusS (parse (second sl)))]
        [else (error 'parse "invali list input")]
    ))]
  [else (error 'parse "invalid input"')]
))

O fato de termos de usar o ~ como sinal de - é porque o parser depende
do parser do Racket. Se o scanner fosse feito por nós, poderíamos usar
um LOOKAHEAD para que pudéssemos testar qual o tipo de -.

=================================================================

    * ArithC
    
                 ArithC
     .-----------' | | '---------------------.
     |      .------' '------.       .........|.........
    numC  plusC           multC     :       ifC       :
          /   \           /   \     :      / | \      :
     ArithC   ArithC  ArithC ArithC : ArithC | ArithC :
                                    :     ArithC      :
                                    '''''''''''''''''''
                                Precisaríamos mudar o ArithC
                                para criar um ifC. Ele teria
                                3 argumentos: condição, ação
                                se verdadeira, ação se falsa.

    * desugar (ArithS -> ArithC)

        ...
        [ ifS (c y n) (ifC (desugar c) (desugar y) (desugar n)) ]
    
    Estamos devolvendo um ArithC usando um desugar.
    
    * Interpretador (ArithC -> number)
    ...
       [ ifC (c s n) (if (zero? (interp c)) (interp n) (interp s)) ] 
    
   
    Não é possível criar um operador de divisão a partir dos operadores
    primitivos já implementados - precisaríamos mexer no ArithC, ou
    usar um primitivo 'inverso' (mas não seria necessário)

(define-type ArithC                  
  [ numC  (n : number) ]             
  [ plusC (l : ArithC) (r : ArithC)                ]
  [ multC (l : ArithC) (r : ArithC)                ]
  [ ifC   (c : ArithC) (y : ArithC) (s : ArithC)   ]
)                                    

(define-type ArithS                    
  [ numS    (n : number)                           ]
  [ plusS   (l : ArithS) (r : ArithS)              ]
  [ multS   (l : ArithS) (r : ArithS)              ]
  [ bminusS (l : ArithS) (r : ArithS)              ]
  [ uminusS (e : ArithS)                           ]
  [ ifS     (c : ArithS) (y : ArithS) (s : ArithS) ]
)

(define (desugar [as : ArithS]) : ArithC
  (type-case ArithS as
    [ numS    (s)     (numC n) ]
    [ plusS   (l r)   (plusC (desugar l) (desugar r))           ]
    [ multS   (l r)   (plusC (desugar l) (desugar r))           ]
    [ bminusS (l r)   (plusC (desugar l) 
                             (multC (numC -1) (desugar r)))     ]
    [ uminusS (e)     (multC (numC -1)   (desugar e))           ]
    [ ifS     (c y n) (ifC (desugar c) (desugar y) (desugar n)) ]
))

(define (interp [a : ArithC]) : number
  (type-case ArithC a
    [numC  (n)     n]
    [plusC (l r)   (+ (interp l) (interp r))]
    [multC (l r)   (* (interp l) (interp r))]
    [ifC   (c y n) (if (zero? (interp c)) (interp y) (interp n))]
))

(define (parse [s : s-expression]) : ArithS
  (cond
    [(s-exp-number? s) (numS (s-exp->number s))]
    [(s-exp-list? s)
      (let ([sl (s-exp->list s)])
        (case (s-exp->symbol (first sl))
          [(+)  (plusS (parse (second sl)) (parse (third sl)))   ]
          [(*)  (multS (parse (second sl)) (parse (third sl)))   ]
          [(-)  (bminusS (parse (second sl)) (parse (third sl))) ]
          [(~)  (uminusS (parse (second sl)))                    ]
          [(if) (ifS (parse (first sl)) 
                    (parse (second sl)) (parse (third sl)))      ]
        [else (error 'parse "invali list input")                 ]
    ))]
  [else (error 'parse "invalid input"')]
))

=================================================================

* ExprC
    
                          ExprC
         .-------------' | | | | |
         |   .-----------' | | | '-------------------.
         |   |    .--------' | '------.              |
        idC numC  |   .------'     multC           ifC
             .----' plusC          /   \          / | \
             |      /   \      ArithC ArithC ArithC | ArithC
             | ArithC   ArithC                     ArithC
             |
           appC 
           /  \
        symb  ArithC              
    
    Para criar funções, primeiro criamos um novo tipo (exigência
    do plai-typed), que será FunDefC. Este novo tipo terá como
    construtor a palavra fdC e 3 outros argumentos:
        - um símbolo, o nome da função;
        - um argumento, que também será um símbolo a ser
          substituído na execução;
        - uma ExprC, que é o que será feito.
    
    (define-type FunDefC
        [fdC (name: symbol) (arg: symbol) (body: ExprC))
    
    ; Um exemplo de definição de função será:
    (fdC 'double 'x (plusC (idC 'x) (idC 'x)))
    
    ; Para chamar a função, usaremos o appC:
    (appC 'double (numC 5))
    
INTERPRETADOR
===============

interp (ExprC) (listof FunDefC) →  num
O interpretador terá 2 argumentos:
    * Uma ExprC com uma árvore;
    * Uma lista de definições de funções, a serem utilizadas
      dentro da árvore.

Dentro do interpretador, dado um 'appC', o que ele precisará 
fazer será buscar na lista de funções (um ambiente, ou tabela
de símbolos) pela função. Então usaremos

subst value arg expr
    * Substitui o VALOR no ARGUMENTO dentro da EXPRESSÃO
    * A expressão será o CORPO de uma função. Então, substituiremos
      o símbolo por este valor

Uma vez feito isso, o appC será substituído pelo bloco com
as substituições já feitas. 

(define-type ExprC                  
  [ numC  (n : number)                        ]
  [ idC   (s : symbol)                        ]
  [ plusC (l : ExprC) (r : ExprC)             ]
  [ multC (l : ExprC) (r : ExprC)             ]
  [ ifC   (c : ExprC) (y : ExprC) (s : ExprC) ]
  [ appC  (f : idC)   (a : ExprC)             ]
)                                    

(define-type ArithS                    
  [ numS  (n : number)                           ]
  [ plusS (l : ArithS) (r : ArithS)              ]
  [ multS (l : ArithS) (r : ArithS)              ]
  [ ifS   (c : ArithS) (y : ArithS) (s : ArithS) ]
  [ appS  (f : idS)    (a : ExprS)               ]
)

(define (desugar [as : ArithS]) : ArithC
  (type-case ArithS as
    [ numS    (s)     (numC n)                                  ]
    [ plusS   (l r)   (plusC (desugar l) (desugar r))           ]
    [ multS   (l r)   (plusC (desugar l) (desugar r))           ]
    [ bminusS (l r)   (plusC (desugar l) 
                        (multC (numC -1) (desugar r)) )         ]
    [ ifS     (c y n) (ifC (desugar c) (desugar y) (desugar n)) ]
    ; Precisamos fazer susugar no argumento, porque ele é 
    ; também uma ExprS (e precisa ser transformado em ExprC)
    [ appS    (f a)   (appC f (desugar a))                      ]
))

(define (interp [a : ExprC] [fds : (listof FuncDefC) ) : number
  (type-case ExprC a
    [numC  (n)     n]
    [plusC (l r)   (+ (interp l fds) (interp r fds))]
    [ifC   (c y n) (if (zero? (interp c)) (interp y fds) (interp n fds))]
    
    ; Primeiro, acha a definição de fd
    ; Então, substitui as macros
    ; Por último, executa a interpretação
    [appC  (f a)
      (local ([define fd (get-fundef f fds)]) ; peda a definição de fd
                                              ; na biblioteca fds
        (interp (subst a                      ; interpreta o resultado
          (fdC-arg fd)                        ; de subst
          (fdC-body fd)
        )
      fds))]
    
    ; Não devem sobrar identificadores livres na expressão
    [idC (_) (error 'interp "não deveria encontrar isso!")]
))

; Substitui os símbolos pelo valor deles
(define (subst [value : ExprC ] [name: symbol] [in : ExprC]) : ExprC
  (type-case ExprC in
    [numC (n) in]
    [idC (s) (cond
        [ (symbol=? s name) value]  ; symbol, substitute
        [ else in ]                 ; otherwise, do nothing
    )]
    [appC  (f a)   (appC (subst value name a))]
    [plusC (l r)   (plusC (sust value name l) (subst value name r))]
    [ifC   (c s n) (ifC (subst value name c)
                        (subst value name y) (subst value name n))
    ]
))

; Acha a função dentro da biblioteca
; Faz uma recursão de cauda, que vira um 'for'
(define (get-fundef [n : symbol] [fds : (listof FunDefC)]) : FunDefC
    (cond
        [(empty? fds) (error 'get-fundef "referência não definida")]
        [(cons? fds) (cond
            [(equal? n (fdC-name (first fds))) (first fds)] ; se achar
            [else (get-fundef n (rest fds))]                ; continue
        )]
))

(define (parse [s : s-expression]) : ArithS
  (cond
    [(s-exp-number? s) (numS (s-exp->number s))]
    [(s-exp-list? s)
      (let ([sl (s-exp->list s)])
        (case (s-exp->symbol (first sl))
          [(+)  (plusS (parse (second sl)) (parse (third sl)))]
          [(*)  (multS (parse (second sl)) (parse (third sl)))]
          [(-)  (bminusS (parse (second sl)) (parse (third sl)))]
          [(if) (ifS (parse (first sl)) 
                    (parse (second sl)) (parse (third sl)))
          [(call) (appS (s-exp->symbol (second sl)) (parse (third sl)) )]
        [else (error 'parse "invali list input")]
    ))]
  [else (error 'parse "invalid input"')]
))

(define biblioteca (list
    [ fdC 'dobro 'x (plusC (idC 'x) (idC 'x)) ]
))

Quanto executamos:
(interp (call 'dobro (mult C (numC 7) (numC 3))))

Temos um problema: geramos duas cópias do 
(mult C (numC 7) (numC 3)). Esse conceito é 'eager',
e é executado na hora. Pelo contrário, temos o 
lazy (que só calcula se necessário).

=================================================================

BINDINGS e AMBIENTES
======================

No último interpretador que vimos, tínhamos um problema: não tínhamos
uma abordagem eager, mas uma lazy. Como substituímos os argumentos,
eles eram calculados somente se necessários. Apesar disso, ficávamos
aumentando a árvore ao introduzir a substituição prévia da expressão
que definia o argumento - e isso o tornava ineficiente.

Para evitar isso, podemos criar uma TABELA DE SÍMBOLOS para os
argumentos da função: quando encontrarmos um símbolo que represente
o nome de uma variável, acessamos a expressão que o define. Essa 
ação de associação é chamada de BINDING, e a tabela de símbolos é um
AMBIENTE.

Conforme adentramos numa função, devemos EXPANDIR um ambiente. 
Colocando um novo ambiente à frente, podemos 'mascarar' a associação
antiga, e usar a nova.

(define-type Binding                       ; Um 'binding', ou associação,
    [bind (name : symbol) (val : number)]) ; é associar um certo símbolo
                                           ; a um valor.

(define-type-alias Env (listof Binding))   ; Diremos que um AMBIENTE 
                                           ; é uma lista de bindings.
(define mt-env empty)                      ; Lista vazia, muitos 
                                           ; ambientess são vazios.
(define extend-env cons)                   ; Usamos um 'cons' para
                                           ; extendermos uma lista,
                                           ; incluindo a nova lista 
                                           ; no início.

;
; O interpretador, agora, além da lista de funções deverá
; levar uma lista de associações.
;
(define (interp [a : ExprC] [env : Env] [fds : (listof FuncDefC)]) : number
  (type-case ExprC a
    [numC  (n)     n]
    [plusC (l r)   (+ (interp l env fds) (interp r env fds))]
    [multC (l r)   (+ (interp l env fds) (interp r env fds))]
    [ifC   (c y n) (if (zero? (interp c)) 
                    (interp y env fds) (interp n env fds))]
    
    ; Primeiro, acha a definição de fd
    ; Então, substitui as macros
    ; Por último, executa a interpretação
    [appC  (f a)
      (local ([define fd (get-fundef f fds)])
        (interp (fdC-body fd)
          (extend-env
            (bind (fdC-arg fd) (interp a env fds))
          env)
        fds))]
    
    ; Não devem sobrar identificadores livres na expressão
    [idC (_) (error 'interp "não deveria encontrar isso!")]
))

(define (lookup [for : symbol] [env : Env]) : number
    (cond
        [(empty? env) (error 'lookup "argument not fund")]

O caso anterior, porém, tem um problema: conforme ampliamos o 
ambiente, as variáveis não podem recuperar suas associações anteriores
quando saem da função. Como resolvermos isso? Podemos restringir o 
ambiente apenas para a função. E como fazer? Em vez de passar juntarmos
os ambientes antigos, podemos uní-lo à um ambiente vazio (não temos 
outra forma de criar um ambiente se não usando o extend-env).

[appC (f a)
  (local ([define fd (get-fundef f fds)])
    (interp (fdC-body fd)
      (extend-env
        (bind (fdC-arg fd) (interp a env fds))
      mt-env)
    fds))]

Esse tipo de associação é chamada de ASSOCIAÇÃO ESTÁTICA, pois o
ambiente não é herdado conforme entramos em escopos mais profundos.
A associação, do outro modo, é a ASSOCIAÇÃO DINÂMICA, que é 
considerada um ERRO de implementação.

=================================================================

Até agora, nossas funções não faziam parte da nossa linguagem.
Agora, vamos tentar inserir as funções como valores, dentro
do contexto da ExprC.

O que mais nos impede, até agora, é que o nosso interpretador
sempre nos devolve um Número. Isso é bem ruim, pois teríamos um
ERRO se déssemos uma função. Vamos, então, introduzir no
interpretador a possibilidade de devolvermos uma FUNÇÃO.

Primeiro, dentro de ExprC, vamos ADICIONAR um fdC (function
definition), em vez de termos a função criada externamente.
Isso nos TIRARÁ a limitação de que tenhamos APENAS funções
definidas anteriormente.

(define-type ExprC
  [ numC  (n : number)                                 ]
  [ idC   (s : symbol)                                 ]
  [ plusC (l : ExprC) (r : ExprC)                      ]
  [ multC (l : ExprC) (r : ExprC)                      ]
  [ ifC   (c : ExprC) (y : ExprC) (s : ExprC)          ]
  [ appC  (f : ExprC) (a : ExprC)                      ]
  [ fdC   (name : symbol) (arg : symbol) (body: ExprC) ]
)

Porém, agora, temos duas novas dificuldade. 'fdC' é, na verdade, um
novo tipo primitivo (além de número). Agora, nossos operadores deverão
verificar TIPOS. Também, nosso interpretador não devolve funções, e
precisaremos ter um valor de retorno especificado.

Nosso tipo de retorno será, a partir de agora:
(define-type Value
    [numV (n : number)]
    [funV (name : symbol) (arg : symbol) (body : ExprC)]
)

Agora, porém, precisaremos definir operadores QUE VERIFIQUEM TIPOS, 
para colocarmos um interpretador.

(define (num+ [l : Value] [r : Value]) : Value
    (cond 
        [(and (numV? l) (numV? r))
            (numV (+ (numV-n l) (numV-n r)))\]
        [else "Error"]
)) 
(define (num* [l : Value] [r : Value]) : Value
    (cond 
        [(and (numV? l) (numV? r))
            (numV (* (numV-n l) (numV-n r)))\]
        [else "Error"]
)) 

O desugar tem que mudar só um pouquinho: agora, precisaremos apenas
fazer um 'desugar' na ExprC do argumento

(define (desugar [as : ArithS]) : ArithC
  (type-case ArithS as
    [ numS    (s)     (numC n)                                  ]
    [ plusS   (l r)   (plusC (desugar l) (desugar r))           ]
    [ multS   (l r)   (plusC (desugar l) (desugar r))           ]
    [ bminusS (l r)   (plusC (desugar l) 
                        (multC (numC -1) (desugar r)) )         ]
    [ ifS     (c y n) (ifC (desugar c) (desugar y) (desugar n)) ]
    [ appS    (f a)   (appC f (desugar a))                      ]
    [ fdS     (f a b) (fdC  f a (desugar b))                    ]
))

(define (interp [a : ExprC] [env : Env]) : number
  (type-case ExprC a
    [numC  (n)     (numV n)] ; garantir o retorno do tipo esperado
    [idC   (n)     (lookup n env)]
    [plusC (l r)   (num+ (interp l env) (interp r env))]
    [multC (l r)   (num* (interp l env) (interp r env))]
    [ifC   (c y n) (if (zero? (interp c)) (interp y fds) (interp n fds))]
    
    ; Primeiro, acha a definição de fd
    ; Então, substitui as macros
    ; Por último, executa a interpretação
    [appC  (f a)
      (local ([define fd (interp f env)])
        (interp (funV-body fd)
          (extend-env
            (bind (funV-arg fd) (interp a env))
          mt-env)
    ))]
    
    ; Não devem sobrar identificadores livres na expressão
    [idC (_) (error 'interp "não deveria encontrar isso!")]
))

(define (lookup [for : symbol] [env : Env]) : Value
    (cond
        ; Base da recursão: lista vazia, não achamos o elemento
        [(empty? env) (error 'lookup with problems - error msg')]
        [else (cond
            ; Procuramos no primeiro elemento. Se for, já o 
            ; devolvemos.
            [(symbol=? for (bind-name (first env)))
                           (bind-val (first env))]
            
            ; Caso contrário, devolvemos o "cdr" do plai-typed
            ; o "rest", aplicando no lookup. É o passo da recursão
            [else (lookup for (rest env))]
        
        )] ; else cond
))
        
(define (parse [s : s-expression]) : ArithS
  (cond
    [(s-exp-number? s) (numS (s-exp->number s))]
    [(s-exp-list? s)
      (let ([sl (s-exp->list s)])
        (case (s-exp->symbol (first sl))
          [(+)  (plusS (parse (second sl)) (parse (third sl)))]
          [(*)  (multS (parse (second sl)) (parse (third sl)))]
          [(-)  (bminusS (parse (second sl)) (parse (third sl)))]
          [(if) (ifS (parse (first sl)) 
                    (parse (second sl)) (parse (third sl)))
          [(func) (fdS (s-exp->sumbol (second sl)) 
                       (s-exp->symbol (third sl))
                       (parse (fourth sl)) )]
          [(call) (appS (s-exp->symbol (second sl)) (parse (third sl)))]
        [else (error 'parse "invalid list input")]
    ))]
  [else (error 'parse "invalid input"')]
))

; Facilitador para a linguagem
(define (interpS [s : s-expression]) 
    (interp (desugar (parse s)) mt-env))

Neste ponto do código, o NOME DA FUNÇÃO não foi usada em quase lugar
nenhum. Isso é muito interessante, pois na realidade nossas funções
não precisam ter nomes - são ANÕNIMAS. Elas são funções λ. E, na 
realidade, é possível apenas definir FUNÇÕES DENTRO DE FUNÇÕES.

Exemplos:
> (interpS '(func f1 x (func f2 x (+ x x))) )
  - Value
  (funC 'f1 'x (fdC 'f2 'x (plusC (idC 'x) (idC 'x))))

> (interpS '(call (func f1 x (func f2 x (+ x x))) 4) )
  - Value
  (funC 'f1 'x (fdC 'f2 'y (plusC (idC 'x) (idC 'y))))

> (interpS '(call (call (func f1 x (func f2 x (+ x x))) 4) 5))
  - Value
  lookup: x não foi encontrado

Esse último erro foi devido a que os ambientes NÃO ESTÃO SENDO HERDADOS.
Se fizéssemos nosso sistema antigo, teríamos o erro de design do escopo
global. Mas se levássemos, APENAS, o escopo anterior, poderíamos ter 
esta flexibilidade.

Este conceito de levar uma parte do ambiente consigo é chamada de 
FECHAMENTO (closure), e as funções usadas que carregam este ambiente
são conhecidas como LAMBDAS (λ).

Não teremos mais fdC, mas lamC, para lambdas:
        
                        { nome
                    fdC { arg   }
                        { corpo } lamC
                          env   }

(define-type ExprC
  [ numC  (n : number)                        ]
  [ idC   (s : symbol)                        ]
  [ plusC (l : ExprC) (r : ExprC)             ]
  [ multC (l : ExprC) (r : ExprC)             ]
  [ ifC   (c : ExprC) (y : ExprC) (s : ExprC) ]
  [ appC  (f : ExprC) (a : ExprC)             ]
  [ lamC  (arg : symbol) (body: ExprC)        ]
)

Porém, agora, temos duas novas dificuldade. 'fdC' é, na verdade, um
novo tipo primitivo (além de número). Agora, nossos operadores deverão
verificar TIPOS. Também, nosso interpretador não devolve funções, e
precisaremos ter um valor de retorno especificado.

Nosso tipo de retorno será, a partir de agora:
(define-type Value
    [numV  (n : number)]
    [closV (arg : symbol) (body : ExprC) (env: Env)]
)

(define (desugar [as : ArithS]) : ArithC
  (type-case ArithS as
    [ numS    (s)     (numC n)                                  ]
    [ plusS   (l r)   (plusC (desugar l) (desugar r))           ]
    [ multS   (l r)   (plusC (desugar l) (desugar r))           ]
    [ bminusS (l r)   (plusC (desugar l) 
                        (multC (numC -1) (desugar r)) )         ]
    [ ifS     (c y n) (ifC (desugar c) (desugar y) (desugar n)) ]
    [ appS    (f a)   (appC f (desugar a))                      ]
    [ lamS    (a b)   (lamC a (desugar b))]
))

(define (interp [a : ExprC] [env : Env]) : number
  (type-case ExprC a
    [numC  (n)     (numV n)] ; garantir o retorno do tipo esperado
    [idC   (n)     (lookup n env)]
    [plusC (l r)   (num+ (interp l env) (interp r env))]
    [multC (l r)   (num* (interp l env) (interp r env))]
    [ifC   (c y n) (if (zero? (interp c))
                        (interp y fds) (interp n fds))]
    
    ; Primeiro, acha a definição de fd
    ; Então, substitui as macros
    ; Por último, executa a interpretação
    [appC  (f a)
      (local ([define f-value (interp f env)])
        (interp (closV-body f-value)
          (extend-env
            (bind (funV-arg f-value) (interp a env))
          f-value) ; Agora, não passamos mais só mt-env, mas
                   ; todo o valor da função
    ))]
))

(define (lookup [for : symbol] [env : Env]) : Value
    (cond
        ; Base da recursão: lista vazia, não achamos o elemento
        [(empty? env) (error 'lookup with problems - error msg')]
        [else (cond
            ; Procuramos no primeiro elemento. Se for, já o 
            ; devolvemos.
            [(symbol=? for (bind-name (first env)))
                           (bind-val (first env))]
            
            ; Caso contrário, devolvemos o "cdr" do plai-typed
            ; o "rest", aplicando no lookup. É o passo da recursão
            [else (lookup for (rest env))]
        
        )] ; else cond
))
        
(define (parse [s : s-expression]) : ArithS
  (cond
    [(s-exp-number? s) (numS (s-exp->number s))]
    [(s-exp-list? s)
      (let ([sl (s-exp->list s)])
        (case (s-exp->symbol (first sl))
          [(+)  (plusS (parse (second sl)) (parse (third sl)))]
          [(*)  (multS (parse (second sl)) (parse (third sl)))]
          [(-)  (bminusS (parse (second sl)) (parse (third sl)))]
          [(if) (ifS (parse (first sl)) 
                    (parse (second sl)) (parse (third sl)))
          [(func) (lamS (s-exp->symbol (second sl)) 
                        (s-exp->symbol (third sl))    )]
          [(call) (appS (s-exp->symbol (second sl)) (parse (third sl)) )]
        [else (error 'parse "invali list input")]
    ))]
  [else (error 'parse "invalid input"')]
))

; Facilitador para a linguagem
(define (interpS [s : s-expression]) 
    (interp (desugar (parse s)) mt-env))

* Ex:
    (interpS '(call (func f (func x (call f 10))) (+ x y)))
    
                            appC
                            /  \
                           /    \
                          /   ...\........
                      lamC    :   addC   :
                      /  \    :   /  \   :
                  id f   lamC :id X  id Y:
                         /  \ '''''''''''''
                        /    \            |
                      id X  appC          |
                            /  \          |
                         id f  numC 10    |
                         ^^^^-------------'
    
    Nesse ponto do fim da árvore, f é aquela subárvore. Temos ERRO 
    porque tanto X quanto Y não tiveram valores de binding associados.
    Mesmo que fizéssemos uma call para definir X no segundo λ, teríamos
    APENAS uma função lambda que faria (+ valor_x y).

Agora, todas as nossas funções são anônimas. Como poderíamos proceder
para DAR NOMES às funções?

Isso já é possível! Só usarmos o call:
    > (interpS '(call (func f (call f 10)) (func x (+ x x))) ) 

Criamos uma lambda que pega como argumento o corpo de uma função E
a aplica no corpo de uma outra closure. Desse modo, estamos fazendo
um binding do CORPO da função com o argumento dela.

Fazendo um açúcar sintático sobre isto, poderíamos ter algum método
de chamar funções. Ou, alterando o parser, poderíamos colocar que 
qualquer símbolo simples fosse interpretado como uma função (e tentasse
ser chamado. Assim, tiraríamos o 'call').
    
Se rodássemos sem o call, teríamos:
    
    > (interpS '(call (func f (call f 10))) ) 
    (closV 'f (appC (idC 'f) (numC 10)) '()  )
            ^ ^^^^^^^^^^^^^^^^^^^^^^^^^  ^- Environment vazio
            | '- expressão que seria executada
'- nome da variável que poderia ser usada aí dentro

=================================================================

ESTADO E MUTAÇÃO

É extremamente desejável que tenhamos uma maneira de criar alterações
nas nossas associações: variáveis.

                          associação
               id --------------------------> valor

                referência
               id ------> localização ------> valor
                   .--.                .--.
                   |  | Tabela que     |  | Tabela que
                   |  | associa id     |  | associa local
                   |  | à local        |  | a um valor
                   '--'                '--' 

Criaremos uma nova estrutura - um 'box' - que será nossas "caixas" que
podem criar valores. A associação NÃO MUDA MAIS (do id para a caixa), 
mas o valor dentro da caixa, sim, pode mudar.

O box terá 3 operações: armazenar, alterar e recuperar.

Para modificarmos o valor de um box, precisaremos de SEQUENCIAMENTO - 
para mudar uma variável, por exemplo, deveremos alterar uma, primeiro,
e depois alterar outra. Haverá uma sequência bem definida para 
criarmos mudanças.

; Agora, o interpretador poderá devolver uma caixa
(define-type Value
    [numV  (n : number)]
    [closV (arg : symbol) (body : ExprC) (env: Env)]
    [boxV  (v: Value)]
)

; Uma caixa, e as funções para ALTERAR e RECUPERAR o valor
; nela poderá ser feita usando outros tipos de ExprC
(define-type ExprC
  [ numC    (n : number)                                 ]
  [ idC     (s : symbol)                                 ]
  [ plusC   (l : ExprC) (r : ExprC)                      ]
  [ multC   (l : ExprC) (r : ExprC)                      ]
  [ ifC     (c : ExprC) (y : ExprC) (s : ExprC)          ]
  [ appC    (f : ExprC) (a : ExprC)                      ]
  [ fdC     (name : symbol) (arg : symbol) (body: ExprC) ]
  [ boxC    (v : ExprC)                                  ]
  [ setboxC (b : ExprC)                                  ]
  [ unboxC  (b : ExprC)                                  ]
)

(define (interp [a : ExprC] [env : Env]) : number
  (type-case ExprC a
    
    ; Dado um boxC, devolvemos um valor boxV (localização, pelo
    ; esquema acima) com, dentro dele, o valor interpretado de A
    ; (valor, pelo esquema acima)
    [boxC   (a)     (boxV   (interp a env))]
    
    ; Retiramos o valor do box devolvido por a (ou teremos erro)
    [unboxC (a)     (boxV-v (interp a env))]
    
    ; Uma sequência será um par de dois valores intepretados.
    ; Essa definição TEM UM PROBLEMA: as modificações feitas
    ; no env de b1 não serão passadas para env de b2. Como 
    ; tratar isso?
    [seqC   (b1 b2) (begin (interp b1 env) (interp b2 env))]
    
    ; Primeiro, acha a definição de fd
    ; Então, substitui as macros
    ; Por último, executa a interpretação
    [appC  (f a)
      (local ([define f-value (interp f env)]) ; acha a definição de fd
        (interp (closV-body f-value)
          (extend-env
            (bind (funV-arg f-value) (interp a env)) ; substitui as macros
          f-value) ; Agora, não passamos mais só mt-env, mas
                   ; todo o valor da função
    ))]
    
    [numC  (n)     (numV n)] ; garantir o retorno do tipo esperado
    [idC   (n)     (lookup n env)]
    [plusC (l r)   (num+ (interp l env) (interp r env))]
    [multC (l r)   (num* (interp l env) (interp r env))]
    [ifC   (c y n) (if (zero? (interp c))
                        (interp y fds) (interp n fds))]
))

Para que não precisemos modificar os environments, ou que os 
environments precisem ser usados para trocar valores (o que nos 
jogaria, novamente, no problema de escopo dinâmico), precisaremos
de uma NOVA TABELA DE SÍMBOLOS, agora para levar dos boxes para
o valor que há no box. Esse será o STORAGE:

            Env                     Storage
            bind                    cell
            símbolo->local          local->valor
            mt-env                  mv-store
            extend-env              override-store
            lookup                  fetch

Esta tabela de símbolo (STORAGE) será como uma memória (que é um caso
concreto do conceito abstrato do storage). Nós não passaremos o env
de um interpretador (para evitar o escopo dinâmico), mas poderemos
passar a memória. Em nossa implementação em Racket, o 'override-store'
será um ampliador da lista (como o extend-env). Mas no caso real,
o storage seria global e compartilhado por todos.

Passar o STORAGE pode ser pensado, abstratamente, como o interpretador
passando um novo 'estado da memória'. Aqui, ele terá importância por
modificarmos as listas. Mas no caso real, a memória seria mudada 
realmente.

Criaremos RESULT como sendo o "contradomínio" da função 'interp',
que será o produto cartesiano dos valores pelo storage:

(define-type Result
    [ v*s   (v : Value) (s : Store)])

(define (interp [e : ExprC] [env : Env] [sto : Store]) : Result
    [plusC (l r)   (num+ (interp l env sto) (interp r env sto))]
;                                       ^------------------^
; Agoram teríamos o mesmo problema do env para o seqC: estamos
; modificando o 'sto' em 'l' e 'r', mas não passamos de um para
; o outro. Como poderíamos fazer? As várias interpretações possíveis
; são decisões semânticas, e dependem da sua própria decisão.
    
    ; Não precisaremos passar e/ou repassar o env. Como só
    ; podemos criar bindings dentro de appC's, e appC's só
    ; agem em campos de função, então ao sairmos de b1 ou 
    ; b2, uma modificação de env deveria morrer lá.
    [seqC (b1 b2) 
        (type-case Result (interp b1 env sto)
            ; Única possibilidade - só um truque esperto
            ; para utilizarmos aqui...
            
            [v*s (v-b1 s-b1) ; só nomes - não têm nada 
                             ; a ver com campos de variáveis
                [(interp b2 env s-b1)])]
)

=================================================================

Estado → Mutação

Antes, nossos identificadores tinham, SEMPRE, um valor fixo. Agora,
estamos tentando realizar uma maneira de fazer com que estes valores
mudem.

Uma das formas que tentamos - alterar a associação pelo Environment - 
é bem ruim. O Environment Dinâmico causa problemas porque as mudanças
em níveis de função acabam indo para níveis superiores (nos quais não
deveriam existir).

Agora, propusemos criar uma nova forma, um REPOSITÓRIO de valor (box).
A associação passa, agora, por um intermediário. O idC (nome) passa a 
servir como uma REFERÊNCIA para uma "posição de memória" (box). A 
associação do box até o valor é mutável (como podemos colocar valores
diferentes num mesmo pedaço de memória).

    Associações estáticas
    
                Environment
    .------------------------------------.
    |             binding                |
    | idC -----------------------> Valor |
    '------------------------------------'
    
    Ambiente com memória
    
        Environment         Storage
    .----------------..------------------.
    |       bind     ||    store         |
    | idC --------> boxC --------> Valor |
    '----------------''------------------'
     symbol       location         value    ← Tabelas de símbolo

Para o box, teremos UMA ESTRUTURA e DUAS OPERAÇÕES:
    
(define-type ExprC
  [ boxC    (arg : ExprC)             ]
  [ setBox  (b : ExprC)               ]
  [ unbox   (b : ExprC)               ]
  [ seqC    (b1 : ExprC) (b2 : ExprC) ]
)

A noção de caixa também deverá ser usada dentro dos 
possíveis valores de retorno. Ela será, realmente, 
apenas uma caixa para guardar outra expressão. E seu
uso, dentro do contexto do interpretador, será apenas
o de retirar o valor de dentro da caixa e aplicar nele
o interpretador.

(define-type Values
  [ numV   (n : number)                   ]
  [ closV  (a : arg) (b : body) (e : env) ]
  [ boxV   (v : Value)                    ]
)

Como temos o STORAGE, agora, precisaremos passá-lo 
de um lado a outro. Quando criamos o environment 
dinâmico, ficávamos passando-o de um lado a outra,
o que nos gerava as consequências indesejáveis de
anteriormente. Mas, agora, o STORAGE será passado.
Na realidade, quando o STORAGE é uma memória, ele
não seria "passado", mas seria de acesso global.
Retornar o STORAGE será passar, de um lado para
outro, "momentos" do STORAGE.

Como ficaria o interpretador? Como só temos um 
valor de retorno, e precisamos passar Valor + 
Storage, então criamos o Result:

(define-type Result
    [ v*s (v : Value) (s : Storage) ]
)

(define (interp [expr : ExprC] [env : Env] [sto : Storage]) : Result
    ...
    ; Para o sequenciamento, precisamos usar um truque: como podemos
    ; modificar o storage em uma delas, devemos passar a possível 
    ; mudança de estado para a próxima operação. Esta opção é uma 
    ; forma de "serialização". Não é a única alternativa. As expressões
    ; poderiam não ter consciência da mudança de storage, o que as 
    ; tornaria paralelizáveis. Porém, o primeiro caso é mais simples.
    
    [ seqC (b1 b2)
        ( type-case Result (interp b1 env sto)
            [ v*s (v-b1 s-b1) (interp b2 s-b1)])
    ]
    ; A solução acima pode ser usada para a soma e o produto.
    ; O type-case no Result é só um truque esperto para que 
    ; peguemos o storage do primeiro argumento.
)

Precisaremos, agora, de uma forma de criar novos boxes. Mas, para 
isso, devemos ARMAZENAR no Storage, usando como "chave" da "tabela
de símbolos" uma posição livre. Como obter esta posição livre? Uma
forma simples é usar um CONTADOR. Mas, aí, temos um problema de 
autorreferência: precisamos de um box para armazenar qual a quantidade
de boxes. Por sorte, temos o Racket por trás, e podemos usar um 
contador DELE como auxiliar.

(define new-loc       < Define um nome para a função anônima
    (let ([n (box 0)] < Cria variáveis para nossa closure
        (λ ()                                 < A closure, usando a
            (begin                            < variável 'n' definida
                (set-box! n (+ 1 (unbox n)))  < no let, serve como 
                (unbox n))                    < "contador" para novos
    )))                                       < endereços na linguagem
)

Operações da caixa no interpretador

(define (interp [expr : ExprC] [env : Env] [sto : Storage]) : Result
  (type-case ExprC a
    [boxC (a)
        (type-case Result (interp a exv sto)
            [v*s (v-a s-a)
                (let ([where (new-loc)])
                   (v*s (boxV where)
                        (override-store (cell where v-a) s-a)))])]

    [appC (f a)
      (type-case Result (interp f env sto) ; acha função
        [v*s (v-f s-f)
          (type-case Result (interp a env s-f) ; argumento com o 
                                                 sto modificado
            [v*x (v-a s-a)
              (let ([where (new-loc)]) ; aloca função
                (interp (closV-body v-f) ; corpo
                        (extend-env (bind (closV-arg v-f) where)
                                    (closV-env v-f))
                  (override-store (cell where v-a) s-a)))
        ])])]
))

========================================================================
"Questões filosóficas"
* A ordem com que são realizadas as operações muda a semântica. Também,
  ter INDEPENDÊNCIA ajuda a paralelizar (independência é a grande
  chave).
* O Store é, em princípio, dinâmico, mas o Environment não. O ESCOPO é
  definido pelo Environment, o ESTADO, pelo Storage. Essa diferença é
  chave.
* Na nossa implementação em Racket, o override-storage coloca uma 
  nova lista na frente - o que é extremamente ineficiente. Se fizermos
  uma busca + sobrescrição, teremos uma economia. Outra questão é
  que, ao sairmos de um escopo, acabamos deixando várias associações.
  Essa memória, teoricamente, ainda está alocada. De tempos em tempos,
  devemos "limpar" o Storage procurando por alocações sem associação.
  Essa é a COLETA DE LIXO (GARBAGE COLLECTION).
* Às vezes, porém, não queremos APAGAR os valores antigos. Isto pode
  ser útil para que possamos manter um LOG das modificações, e desfazer
  operações. Este conceito é chamado de STM (Software Transition Memory).

=================================================================

VARIÁVEIS
==========
Para criarmos variáveis, TIRAMOS as opções de box/setbox/unbox de
dentro do parser. Nosso id's viram var's. 

LET
====
Como poderíamos criar um 'let' na nossa linguagem?
O objetivo do let é:
    1) Criar um novo símbolo;
    2) Salvar o valor neste símbolo;
    3) Executar alguma ação com este símbolo associado
       a este valor.

Em Racket, temos a analogia:
((λ(x) corpo) val) ↔ (let [x val] corpo)

Na nossa linguagem, podemos ter o açúcar:
    [letS (s : symbol) (v : value) (b : body)]

No Desugar, transformaríamos para o λ:
    [letS (id val expr) (appC (lamC id (desugar expr)) (desugar val))]

O interpretador é o mesmo (pois o let é açúcar), mas precisamos 
colocar algo no parser:
    [(def) (letS (s-exp->symbol (second sl)) 
            (parse (third sl)) (parse (fourth sl)) 
    )]

Usando isso, podemos ter, por exemplo:
> (parse '(def b b b))
    (letS 'b (varS 'b) (varS 'b))

> (desugar (parse '(def b b b)))
    (appC (lamC 'b (varC 'b)) (varC 'b))

> (interp (desugar (parse '(def b b b))))
    ERROR: lookup: b não foi encontrado

RECURSÃO
=========

- Dados → referenciar { outro elemento do mesmo tipo
                      { a si mesmo
- Controle → função recursiva

        .-----.       |   outro elemento do mesmo tipo
        |     |       |   .---.   .---.   .---.   .---.
        |--.--|       |   | *-:-->| *-:-->| *-:-->| *-:--.
        |  |  |       |   '---'   '---'   '---'   '---'  |
        '--'--'       |     ^----------------------------'
         /   \        |   
        /     \       |             a si mesmo
   .-----.   .-----.  |               .---.
   |     |   |     |  |               | *-:-.
   |--.--|   |--.--|  |               '---' |
   |  |  |   |  |  |  |                 ^---'
   '--'--'   '--'--'  |   

Para criarmos AUTORREFERÊNCIAS, precisaremos de dois passos:
1) Criar uma associação (variável/box) não definida;
2) Depois, trocar o valor para a localização da própria variável.

As duas 'dependências' necessárias são:
1) Criar MUTAÇÕES na variável;
2) Usar SEQUENCIAMENTO de ações.

Esse procedimento nos permitiria CORRIGIR o exemplo do let da 
seção anterior (terceiro exemplo). Se pudermos PEGAR o próprio
'endereço' da variável b (guardando em b a chave da tabela de
símbolos store).

Um outro problema de autorreferência seria:
> (interpS 
    '(def fat 1729 (func n (if n (* n (call fat (-n 1))) 1)))
  )
    ERROR: lookup: fat não foi encontrado

Poderíamos tentar resolver usando um SEQUENCIAMENTO. Com ele,
podemos alterar o STORE de modo que, 
> (interpS '(def fat 1729 ; define fat com um valor dummy
    (seq 
        ; Troca 'fat' pelo valor que ela deveria ter: o
        ; corpo da função fatorial. Não temos o problema,
        ; pois fat já foi definido no início.
        (:= fat (func n (if n (* n (call fat (-n 1))) 1)))
        
        ; Agora, com o corpo definido, e sabendo que nós
        ; já tínhamos o símbolo definido, a recursão funciona.
        (call (fat 10))
)))

O resultado desta mudança é que acabaremos definindo 'n' várias
vezes, pois cada vez que entramos numa nova chamada, definimos
um novo número 'n'. Se tivéssemos otimização, dado que esta é
uma recursão de cauda, não precisaríamos criar estes environments
várias vezes: apenas reutilizaríamos o já existente - e ele se
tornaria um laço.

Essa solução que encontramos usa, de certa maneira, uma recursão
implícita. Usamos a alteração de ESTADO para criar a recursão. 
Haveria alguma maneira de criarmos a recursão SEM STORE?

; Um Fibonacci tradicional seria este. 
; O que devemos colocar no passo para criar a recursão?
(λ (n)
    (if (zero? n)
            1
            (* n (? (- n 1)))
))

; Precisamos usar um "duplicador", chamado de GERADOR Y.
; Ele consiste de uma fábrica de funções, que pode ser
; recriada pelo corpo da função recursiva.
(
                .- Este primeiro λ serve APENAS para dar o "chute
    ............'  inicial" e começar o processo recursivo.
    (λ (m) (m m))   <-----. Parâmetro desta closure
        (λ (f)         ---' <-----. O que é gerado por esta closure:
            >> (λ (n)          ---' nosso fibonacci
            >>     (if (zero? n)
            >>         1
            >>         (* n ((f f) (- n 1)))
            >> ))
        )
)

; Para não precisarmos mais colocar o '(f f)' no meio da função,
; e abstrairmos o código do fatorial de dentro do gerador Y, 
; podemos chamar o (f f) de 'g'.
; 
(
    (λ (m) (m m))   <-----. Parâmetro desta closure
        (λ (f)         ---' 
            >> (λ (g)      
            >>     (λ (n)        
            >>         (if (zero? n)
            >>             1
            >>             (* n (g (- n 1)))
            >> )))
            (f f)
    )
)

; Agora, podemos simplesmente chamar nossa função recursiva de 
; de "p". Então, para usar o fatorial, bastará colocá-lo como
; ARGUMENTO da nossa primeira função:
(
    (λ (p)
        (
            (λ (m) (m m))
            (λ (f) (p (f f) ))
        )
    )
    (λ (g) (λ (n) (if (zero? n) 1 (* n (g (- n 1)))
)

; A última versão, porém, entra em LOOP INFINITO, pois nossa 
; função '(f f)' é calculada na hora em que a lista é interpretada.
; Assim, já na nossa primeira execução, entraríamos em loop.
; Para POSTERGAR a execução de (f f), criamos um dummy λ, que chama
; a função (f f) com parâmetro 'a'. Mas isso não faz nada.
(
    (λ (p)
        (
            (λ (m) (m m))
            (λ (f) (p (λ (a) ((f f) a))))
        )
    )
    (λ (g) (λ (n) (if (zero? n) 1 (* n (g (- n 1)))
)

Para criar um combinador na nossa linguagem, usaríamos:

(call
    (call 
        (func p
            (call
                (func m (call m m))
                (func f (call p (func a (call (call f f) a)) ) )
            )
        )
        ; Fibonacci:
        (func g (func n (ifS n 1 (mulS n (call g (bminusS n 1))))))
    )
    ; Número para chamar o Fibonacci:
    42
)

=================================================================

ORIENTAÇÃO A OBJETOS
======================

Semânticamente, um objeto é o encapsulamento de uma ideia, para
abstrairmos estes conceitos.

Concretamente, podemos pensar em um objeto como uma coleção de 
VALORES (dados) com métodos associadas a eles (funções).

Em nossa linguagem, uma função é um tipo de primeira classe.
Logo, se pudermos criar uma LISTA com valores, já podemos ter
uma classe/objeto.

Porém, precisamos ACESSAR estes valores: precisamos ter um SELETOR
que associa um nome aos seus valores (uma TABELA DE SÍMBOLOS).

Como estamos no contexto de uma linguagem funcional, usaremos listas
como nossa TABELA DE SÍMBOLOS. Teremos mais duas estruturas:

* No core, o objC:
    { lista de nomes, lista de ExprC }
    [ objC (ns : (listof symbol)) (es : (listof exprC)) ]
    A lista de nome corresponde aos nomes das funções
    enquanto as expressões são o corpo delas
    
* Para termos um objeto concreto, usamos um objV:
    { lista de nomes, lista de Valores }
    [ objV (ns : (listof symbol)) (vs : (listof Value)) ]

Dado um objV, precisaremos ter uma maneira de conseguir o valor
específico de UM ARGUMENTO dentro da closure. Para tanto, usaremos
o 'msgC' no Core (vindo da ideia do Smaltalk que "enviamos uma 
mensagem" ao objeto para requisitar um de seus argumentos). Ela
ficaria:
    
    [ msgC (o : ExprC) (n : symbol) ]
    Busca o valor/campo (n) no objeto (o)

Mas, no açúcar, poderíamos adicionar um pouquinho mais: a aplicação,
para quando tivermos um argumento que for uma closure (como o->n(a) 
ou o.n(a)):
    
    [ msgC (o : ExprS) (n : symbol) (a : ExprS) ]

Para o desugar, algumas modificações da implementação:
    
    ; Usaremos um map para percorrer a LISTA de campos para,
    ; então, desaçucararmos cada elemento.
    [ objS   (ns es) (objC ns (map (λ e) (desugar e)) es) ]
    
    ; Faça desugar do objeto, selecione o campo 'n' com msgC
    ; e então aplique o desugar de a em appC 
    [ msgS   (o n a) (appC (msgC (desugar o) n) (desugar a)]

Interpretador, sem STORE (porque não o estaos usando):
    
(define (interp [a : ExprC] [env : Env]) : Value
  (type-case ExprC a
    ...
    [objC (ns es) (objV ns (map (λ (e) (interp e env)) es)) ]
    [msgC (o n)   (lookup-msg n (onterp o env))] ; seletor
  )
)

(define (lookup-msg [n : symbol] [o : obj]) : Value
    (type-case Value o
        [objV (nomes valores)
            (cond 
                (empt? nomes) (error 'Argument does not exist')
                [else (cond
                    ; Procuramos no primeiro elemento. Se for, já o 
                    ; devolvemos.
                    [(symbol=? n (first nomes))
                         (bind-val (first valores))]
                    
                    ; Caso contrário, devolvemos o "cdr" do plai-typed
                    ; o "rest", aplicando no lookup. É o passo da recursão
                    [else (lookup-msg
                        n (objV (rest nomes) (rest valores))
                    )]
                
                )] ; else cond
            )]
        [else (error 'lookup error')]
))

=================================================================

Até agora, usávamos o plai-typed com várias estruturas sobre ele.
Agora, vamos MUDAR e usar um SUBCONJUNTO do próprio Racket para 
tornar mais rápido.

Nossa nova definição de objeto será usando o objeto como um 
"multiplexador": basicamente, ele será um λ que recebe como parâmetro 
um NOME DO MÉTODO. Deste nome, virá uma closure (o "corpo" da função)
e poderemos aplicar o método.

(define (o-constr-1 x)
    (lambda (m)
        (case m
            [(addX) (lambda (y) (+ x y))]
)))

Os atributos do construtor (no caso, o x) estão salvos no Environment
do primeiro lambda (com parâmetro do nome do método).

Para facilitar a "aplicação" do método, usaremos novamente uma estrutura 
chamada 'msg' (que estava em nosso antigo Core). Ele receberá 3
argumentos: o objeto sobre o qual aplicaremos, o nome do método e 
uma LISTA DE ARGUMENTOS para o método. Usando as características do
Racket/Plai, essa lista de argumentos será passada usando o operador
'.' da lista, que separa o "resto dos argumentos" como uma sublista
própria.

(define (msg o m . a)
;            ^ ^   ^-- argumentos (o . separa o "resto da lista", 
;            | '-- método          como o @_ do Perl)
;           obj 
    (apply (o 'm) a) )

Primeiro, chamamos o objeto passando como parâmetro o NOME do método.
Em seguida, usamos o operador APPLY, do Racket, que "quebra" a lista
em pedaços e os passa como parâmetros separados para o método devolvido
para aquele dado objeto.

O nosso 'msg' funciona, então, como um '.' do C/C++/Java/Python.

A partir de agora, veremos vários conceitos de POO e suas implementações
usando o Racket.

MUDANÇA DE ESTADO
===================

Podemos criar mudanças de estado também (o que é bem útil, pela
maneira do objeto):

(define (o-state-1 count)
    (lambda (m)
        (case m
            [(inc) (lambda () (set! count (+ count 1)))]
            [(dec) (lambda () (set! count (- count 1)))]
            [(get) (lambda () count)]
)))

MÉTODOS PRIVADOS
===================

Também conseguiremos ter métodos privados: para tanto, usamos o
'let', que é (no fundo) um lambda e que, por levar a associação
APENAS em seu Environment, terá o símbolo como local:

(define (o-state-1 init)
    (lambda (m)
        (let ([count init])
            (case m
                [(inc) (lambda () (set! count (+ count 1)))]
                [(dec) (lambda () (set! count (- count 1)))]
                [(get) (lambda () count)]
))))

MÉTODOS ESTÁTICOS
===================

Para termos métodos/atributos estáticos, apenas precisamos mudar 
a posição do "let":

(define (o-state-2 init)
    ; Se trocarmos o argumento por um λ, teremos um método estático
    (let ([count 0])
        (begin
            (set! count (+ count 1))
            (lambda (m)
                (case m
                    [(inc) (lambda () (set! count (+ count 1)))]
                    [(dec) (lambda () (set! count (- count 1)))]
                    [(get) (lambda () count)]
)))))

AUTORREFERÊNCIA
===================

E o problema da autorreferência? Devemos usar o truque de setar um
objeto vazio (com valor 'dummy'):

(define (o-self init)
  ; Criamos o símbolo com um valor dummy
  (let ([self 'dummy])
    (begin
      ; Setamos o objeto, agora, como sendo nosso lambda
      ; seletor. Mas como o símbolo está definido, podemos
      ; nos referenciar a ele mesmo.
      (set! self
        (lambda (m)
          (case m
            [(inc) (lambda () (set! count (+ count 1)))]
            [(dec) (lambda () (set! count (- count 1)))]
            [(get) (lambda () count)]
            [(first)  (lambda (x) (msg self 'second (+ x 1)))]
            [(second) (lambda (x) (+ x 1))]
      )))
      self
)))

AUTORREFERÊNCIA (com combinador-Y)
===================================

(define (o-self-no! init)
  ; Criamos o símbolo com um valor dummy
  (lambda (m)
    (case m
      ; Estamos passando os métodos como referência para si
      ; próprio. Dado que ele é argumento, o símbolo pode ser
      ; usado.
      [(first)  (lambda (self x) (msg/self self 'second (+ x 1)))]
      [(second) (lambda (self x) (+ x 1))]
)))

(define (msg/self o m .a)
  (apply (o m) o a))

LATE BINDING
===================

Podemos criar, também, uma chamada em tempo de execução (late binding).
Ela surge naturalmente, pois BUSCAMOS o nome de um método, dentro do
objeto, durante o tempo de execução. No exemplo seguinte, de uma 
árvore, NÃO TEMOS garantia que o método 'add' existe. Porém, a
busca pelo nome na nossa "tabela" de símbolos é o late binding.

; nó externo (vazio)
(define (mt)
    (let ([self 'dummy])
        (begin 
            (set! self
                (lambda (m)
                    (case m
                        [(add) (lambda () 0)] ; retorna 0
))))))

; nó interno (com valor)
(define (node v l r)
    (let ([self 'dummy])
        (begin 
            (set! self
                (lambda (m)
                    (case m
                        [(add) (lambda () (+ v  ; soma filhos esq/dir
                                            (msg l 'add) 
                                            (msg r 'add)
                        ))]
            )))
)))

=================================================================

HERANÇA
=========

* métodos ↔ nomes
    - Conjunto finito e fixo ou não;
    - Nomes podem ser estáticos ou dinâmicos.

    .----------.--------------.------------.
    | conjunto |     fixo     |  variável  |
    |   nome   |              |            |
    |----------|--------------|------------|
    | Estático |     Java     |  --------  |
    |          |              |  --------  |
    |----------|--------------|------------|
    | Dinâmico | Introspecção | linguagens |
    |          |  (Reflexão)  | de  script |
    '----------'--------------'------------'
    
    Quando temos um conjunto de métodos fixos, com nomes dinâmicos, 
    temos uma analogia ao Reflections do Java, em que podemos acessar
    um campo de uma classe usando uma string. No caso acima, tratamos
    apenas de métodos, mas a introspecção é mais poderosa que isso.
    
    Usar métodos da maneira variável, com um conjunto dinâmico, é
    comum a linguagens de script como Perl e Python. Em ambos, o 
    objeto é representado por um HASH com chave sendo string e 
    valor uma variável ou método. Poderíamos ter mais de uma 
    chave associada ao objeto, e mesmo criar novos métodos durante
    a execução.
    
    Nesta disciplina, trataremos principalmente do conjunto estático
    e fixo, comum às linguagens compiladas.
    
    A versão estática/variável não faz tanto sentido - de que adianta
    podermos definir vários métodos, se não pudermos colocar novos 
    nomes? É mais simples tomar o caminho estático/fixo e/ou o 
    dinâmico/variável.
    
    Em nossa sub-linguagem do Racket, como identificar qual o método?
    
    (define o-e
        (λ (m)
            (case m ; para identificar os símbolos
                [f1  (λ (a) ...)]
                [g42 (λ (b) ...)]
                [else (error "Method not found")]
    )))
    
    E para chamar, usamos:
    (msg o-e 'f1 13) → desaçucarado para ((o-e 'f1) 13)
    
    No else acima, temos um erro. Mas o que precisaríamos se quiséssemos
    herança? Simples! Bastaria chamarmos o método do pai. Assim, 
    sequenciaríamos uma hierarquia até a sua raiz. A alteração ficaria:
    
    (define o-e
        (λ (m)
            (case m ; para idntificar os símbolos
                [f1  (λ (a) ...)]
                [g42 (λ (b) ...)]
                [else (father m)]
    )))
    
* Construtores em Herança
    
    Para criarmos definitivamente Herança, precisamos ter uma 
    referência/apontador para o 'pai' do objeto. Mas ao criarmos 
    o objeto filho, não temos o objeto pai ainda. Para fazermos a
    construção, precisaremos de um argumento ADICIONAL no construtor
    de um objeto: o construtor da classe PAI. Com ele, poderemos
    começar construindo a classe pai e, depois, ir para a filha.
    
    (define (filho constr-pai a1 a2 ... an)
        (let ([pai (constr-pai a1 a2 ... an)
              [self 'dummy])
            (begin
                (set !self
                    (λ(m)
                        (case m
                            [f1  (λ (a) ...)]
                            [g42 (λ (b) ...)]
                            ...
                            [else (pai m)]  ; chamada de função para 
                                            ; o método pai
                    )))
                self
            )
    ))
    
    Se em vez de um construtor do pai tivéssemos uma lista deles,
    e na resolução do conflito usássemos um case (if-else), 
    teríamos um esquema de HERANÇA MULTIPLA (e que pode gerar muita
    dor de cabeça).

* Protótipos
    
    Quando temos classes, cada vez que construímos um novo objeto
    estamos fazendo toda a hierarquia de classes para o novo 
    objeto. Porém, e se ao invés disso passássemos uma REFERÊNCIA
    PARA UM OBJETO JÁ PRONTO? Essa é a ideia de PROTÓTIPO, que é 
    mais abstrato que CLASSE. Vários 'clones' podem estar associados
    ao mesmo protótipo, e depois se desassociarem dele.
    
    Essa é a forma pela qual JavaScript faz POO.

* Busca por métodos
    
                      /\        ()      || 
                      ||        /\      || 
      Sair da classe  ||       /  \     || Sair de uma classe PAI
      filha e ir para ||      /    \    || e buscar métodos na 
      a classe pai é  ||     ()    ()   || filha é chamado de INNER
      natural da      ||     /\     |   || 
      herança         ||    /  \    |   || 
                      ||   /    \   ()  || 
                      ||  ()    ()      \/ 

* Problemas de herança múltipla
    
    Quando temos HERANÇA MÚLTIPLA, temos um grande problema: nossa
    árvore da hierarquia de classes se torna um GRAFO. E como um
    grafo, podemos ter subcasos extranhos:
    
                       ()     O diamante é um caso
                       ^^     bem patológico. 
                      /  \    
                     /    \   Deveríamos ter apenas
                    ()    ()  1 ou 2 objetos da 
                     ^    ^   classe pai de todos
                      \  /    no nível 1?
                       \/     
                       ()     
    
    E como deveríamos percorrer o grafo? Busca em largura ou
    profundidade?
    
* Mixin e Trait
    
    Uma solução para problemas de herança múltipla é fazer o MIXIN, que 
    consiste em "injetar" métodos dentro de uma classe. De certa 
    maneira, estamos pegando os métodos da classe filha e estamos 
    substituindo/tirando da classe pai. É a solução adotada, por 
    exemplo, por C++ para resolver seus problemas de herança múltipla.
    
    Ainda assim, poderíamos ter 2 mixin's para cada pai na herança
    múltipla. E se ambos os ramos tivessem métodos de mesmo nome,
    haveria conflito na hora de montar a classe final. TRAIT surgiu
    para os compiladores gerarem erro se isso ocorrer. Sem ele, o
    compilador tenta resolver de alguma maneira.
