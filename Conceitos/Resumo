Capítulo 1 - Introdução

"define-type" cria um novo tipo enquanto "type-case" verifica qual o tipo e toma a devida ação.

===========================

Capítulo 2 - Primeira linguagem

  Criaremos uma lingaugem simples que executa operações aritméticas e o condicional if

define-type ArithC
  Definição de uma primeira linguagem (ArithC), que executa apenas soma e multiplicação.
  
parse
  Recebe uma s-expression e retorna um ArithS.
  Para isso, é necessário uma função que recebe uma entrada (s-expression) para ser processada e retornada em um determinado formato que nossa linguagem ainda precisa interpretar.

interp
  Recebe um ArithC e retorna um number.
  A saída do parse é então interpretada pelo interp e enviada para o compilador do plai-typed em um formato que ele consegue ler.
  
define-type ArithS
  Como as operações de subtração e menos unário não passam de aplicações de soma e de multiplicação, cria-se um novo tipo (ArithS) com açucar sintático. Essas operações são devidamente tratadas no parse, interp e desugar.
  
desugar
  Recebe um ArithS e retorna um ArithC.
  Como o ArithS é um ArithC com açúcar sintático, precisamos de uma função que remova esse açucar. A função desugar recebe como entrada ArithS e retornar como ArithC.
  
Condicional (if)
  Como o if não é nem uma operação de adição nem de multiplicação, ele precisa ser colocado diretament no ArithC e, portanto, no ArithS também. Por causa disso, ele precisa ser devidamente tratado no parse, interp e desugar.
  
===========================

Capítulo 3 - Segunda linguagem

  Aprimoraremos a linguagem possibilitando que sejam criadas funções para serem chamadas de tal forma que se torna desnecessário reescrevê-la todas as veze que quiser a utilizar. Entretanto, essas funções PRECISAM de uma biblioteca para serem armazenadas.

define-type FunDefC
  Por hora, não há funções para serem chamadas - apenas blocos de código que precisam ser digitados todas as vezes que quisermos o usar. O tipo FunDefC possui um nome (symbol), argumento (symbol) e um corpo (ExprC, que será definido mais adiante). Por enquanto, possui apenas um argumento.

define-type ExprC
  Em comparação com ArithC, ExprC precisa de duas novas entradas: identificadores (idC) e aplicação de função (appC). Enquanto o idC serve para encontrar os símbolos que serão substituidos pelos devidos argumentos, o appC serve para efetivamente chamar a função, uma vez que seus argumentos são o nome da função e seu argumento.

ExprS & desugar
  desugar recebe um ExprS e retorna um ExprC.
  ExprS é um tipo definido por define-type.
  Se quiser manter o açúcar sintático como no capítulo 1, é necessário fazer as respectivas alterações em ArithS e desugar para se tornarem ExprS e desugar (do ExprS), ou seja, adicionar idS e appS.

subst
  Recebe ExprC, symbol e ExprC e retorna ExprC.
  Função que recebe três argumento a, b e c.
  c é uma ExprC com um symbol b que será substituído por uma outra ExprC a.
  O objetivo da função é substituir o argumento passado, que chega como um símbolo, para o devido formato ExprC.

interp
  Recebe ExprC e listof FunDefC e retorna number.
  Age da mesma forma que o interp do ArithC, mas adaptado para utilizar ExprC e FunDefC.

get-fundef
  Recebe um symbol e um listof FunDefC e retorna FunDefC
  Busca a função dentre as funções existentes na listof FunDefC que foi passada como argumento.

parse
  Recebe uma s-expression e retorna uma ExprS.
  Funciona da mesma forma que o parse do ArithC, mas com um caso a mais: se first sl for igual a call. Ou seja, ele verifica se é uma chamada de função e toma a ação necessária.

define biblioteca
  Lista de fdC (listof fdC).
  É uma lista de funções definidas para poderem ser chamadas pelo nome ao invés de terem que ser digitadas todas as vezes que quiser que sejam usadas. É uma dessas que é chamada como segundo argumento do interp.

===========================

Capítulo 4 - Ambientes (Environments)

  Para evitar que as funções sejam percorridas sempre duas vezes, cria-se os environments, que armazenam o valor (number por hora) de cada symbol em uma lista

define-type Binding
  Ao utilizar a função subst, as funções são percorridas duas vezes: uma para trocar os argumentos e outra para interpretar a função (e executá-la). O tipo Binding associa um symbol a um number de tal forma que a troca seja feita apenas em tempo de execução.

define-type-alias Env (listof Binding) & define mt-env empty & define extend-env cons
  Uma lista de Bindings forma o environment. mt-env é um environment vazio e extend-env é uma função que estende o environment. Graças ao environment, não é mais necessário utilizar a função subst.

interp
  Recebe uma ExprC, um Env e um listof FunDefC e retorna um number
  interp recebeu mais um argumento: o environment. Todas as chamadas recursivas agora precisam receber env como argumento também. A associação do Binding é feita nesta parte.

lookup
  Recebe um symbol e um Env e retorna um number
  Procura o symbol passado no Env e retorna seu respectivo valor caso exista no Env.

===========================

Capítulo 5 - Funções como valores

  Por hora, as expressões retornam apenas números. Neste capítulo, isso será aprimorado.

define-type ExprC
  Passa a ter o tipo fdC também como uma estrutura do tipo.
  appC-fun passa a ser ExprC ao invés de symbol.

define-type Value
  Novo tipo de retorno para o interp, já que agora as funções retornam valores ao invés de apenas números.

num+ & num*
  Recebem Value, Value (os dois elementos da soma ou da multiplição) e retornam Value (resultado)
  Como agora a linguagem trabalha com Value e não apenas number, as operações aritméticas precisam ser devidamente adaptadas.

interp
  O interp agora precisa verificar a estrutura fdC também.
  appC não precisa mais buscar f com get-fundef. Ao invés disso, ele é interpretado chamando (interp f env).

desugar
  Adiciona-se o fdS
  Altera o appS para que desugar seja executado no fun também.

parse
  cond passa a verificar mais um caso: se a s-expression recebida é um symbol. Em caso positivo, retorna idS convertendo a s-expression para um symbol.
  O caso de a s-expression ser uma lista passa a ter mais um caso verificado: se o primeiro symbol da lista é "func" e executa a ação correspondente (fdS).

interpS
  Apenas como um apoio, ele é apenas um interp com o mt-env já incluido, removendo a necessidade de incluí-lo em toda chamada de função.

===========================

Capítulo 6 - Closures (Fechamentos)

  Associações precisam ser propagadas para funções internas (funções dentro de funções por exemplo). Entretanto, os environments são criados a partir do zero a cada aplicação de função.

define-type ExprC
  fdC -> lamC
    (name : symbol) -> removido, pois nomes não são mais necessários.

define-type Value
  funV -> closV
    (name : symbol) -> removido
    (env : Env) adicionado
  O valor de retorno não é mais uma função ou um número, mas um closure ou número.

desugar
  fdS -> lamS
    (n a b) -> (a b)
    Correspondente mudança na ação tomada.
  Precisa fazer as alterações correspondentes.

parse
  fdS -> lamS
    Correspondentes mudanças na ação tomada.
  Prcisa fazer as alterações correspondentes.

interp
  fdC -> lamC
    (n a b) -> (a b)
    (funV n a b) -> (closV a b env)
  appC passa a usar o environment do closure chamado (closV-env) ao invés de um environment vazio (mt-env)

Nomeando funções
  É possível dar nome para as funções, bastando colocá-las no environment. Também é possível usar o desugar para dar nomes "menos feios".

===========================

Capítulo 7 - Mutação
