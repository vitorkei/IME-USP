AÇÚCAR
========

O processo de construção de açúcar permite transformar uma sintaxe 
em outra:
            sintaxe A ----------------------> sintaxe B
                                               (core)

O primeiro exemplo que utilizamos para açúcar sintático foi:
        (let (var val) body) --> ((λ (var) body) val)

Mas assim como conseguimos criar regras de açúcar diretamente na 
linguagem açucarada, também poderíamos fazê-lo EM TEMPO DE INTERPRETAÇÃO
(on the fly).

No Racket, existe essa opção, por meio dos comando:
    (define-syntax macro regra)
                         ^^^^^- { syntax-rules
                                { syntax-case

Criaremos um "novo let". Para que o próprio Racket não se confunda, 
usaremos o nome "my-let" com números 1,2,... para eles.

(define-syntax my-let-1
    (syntax-rules () ; arg para definir associações locais às regras
        
        ; Lista de regras de tradução
        [(my-let-1 (var val) body) ((lambda (var) body) val)]
        
        ; Cada uma das regras trabalha como MACRO - nenhuma 
        ; modificação é criada e só se traduz de um para outro.
))

Podemos aceitar argumentos como listas de qualquer tamanho, usando
o símbolo "...". Ele funciona como os TEMPLATES VARIÁDICOS do C++ 
ou as funções com múltiplos argumentos do C:

                    ..----------------------------..-------------..
                    \/                            /\             /\
         Constroi 'n' pares (var val)       Pega 'n' vars  Pega 'n' vals
                _____________                 _________       ________
    [(my-let-2 [(var val) ...] body) ((lambda (var ...) body) val ...)]

O Dr. Racket tem a opção MACRO-STEPPER, que mostra qual o resultado das
EXPANSÕES DE MACROS criadas pelo define-syntax. Entretanto, nem sempre
o resultado pode ser o esperado, pois o Racket pode OTIMIZAR os
argumentos variádicos para seus próprios lambdas.

PROBLEMAS
-----------

Os macros são interessantes, mas podem gerar problemas parecidos com as
macros de C/C++: os erros não são checados quando definimos as novas
regras sintáticas. Por exemplo

* Racket                          | * C/C++
                                  | 
; Em vez de um símbolo para       | // Definição do Macro em C ou C++.
; argumento, colocamos um número  | // Não usamos paerênteses suficientes
(my-let-1 (1 5) 1)                | #define SQUARE(X) X*X
                                  | 
; A tradução ficaria:             | // A expressão:
((λ (1) 1) 5)                     | SQUARE(2+2);
                                  | 
; O erro, porém seria:            | // Seria traduzida em:
    lambda: not an identifier,    | 2+2*2+2
    identifier with default, or   | 
    keyword in: 1                 | // O resultado 8 é diferente de 16

SYNTAX-CASE
=============

Poderemos usar,agora, o SYNTAX-CASE, mais geral, para que façamos
regras válidas.

Ele receberá uma lista de pares [A, B], com:
* A, o padrão a ser identificado na linguagem;
* B, cujo VALOR INTERPRETADO será associado a A;

O fato dele associar o VALOR INTERPRETADO da expressão B pode ser 
ruim, caso queiramos apenas devolver uma expressão. Para isso, usaremos
um truque relacionado ao operador #' (à frente).

; Associamos o nome 'my-let-3' a um símbolo x. O 'x' é um auxiliar, 
; que permite chamar RECURSIVAMENTE a estrutura do define-syntax.
; Isso é importante porque o símbolo "my-let-3" poderia ser utilizado
; dentro do pattern ou valor. Temos, então, este auxiliar.
(define-syntax (my-let-3 x)
    
    ; O 'x' de acima é passado para o syntax-case, como um 'this'.
    (syntax-case x ()
        [
         ; Padrão a ser identificado
         (my-let-3 (var val) body) 
         
         ; O símbolo #' serve para que o syntax-case devolva a 
         ; própria expressão, e não o resultado da execução dela.
         ; Em geral, para não executarmos, usamos apenas '. Porém,
         ; ' transforma uma expressão em s-expression. O syntax-case
         ; EXIGE que o argumento seja um PEDAÇO DE SINTAXE - e o
         ; operador #' é o que evita a execução e devolve um pedaço
         ; de sintaxe. O #' será necessário em todos os casos em que
         ; quisermos usar um pedaço do pattern, sem executá-lo (o que
         ; seria, inclusive, impossível, pois ele não existe ainda
         ; dentro da macro).
         #'((lambda (var) body) val)
        ]
))

O my-let-3 faz exatamente o mesmo que o my-let-2, mas usa o syntax-case.
Entretanto, o syntax-case tem uma segunda forma que pode ser útil.
Ele não receberá mais pares [A B], em que associa-se o padrão A 
ao valor (B). Teremos como argumentos trincas [A P B], com:
* A, o padrão;
* B, cujo valor interpretado será associado a A;
* P (predicado), as RESTRIÇõES a serem avaliadas.

(define-syntax (my-let-4 x)
    (syntax-case x ()
        [
         ; Padrão a ser identificado 
         (my-let-4 (var val) body) 
        
         ; Predicado a ser avaliado
         ; Se 'var' não for identificador, dará erro.
         (identifier? #'var)
         
         ; Igual ao caso do my-let-3
         #'((lambda (var) body) val)
        ]
))

SYNTAX-CASE RECURSIVO
=======================

Vejamos um exemplo de syntax-case RECURSIVO. Para isso, vamos
implementar uma forma de OR usando IF's recursivamente:

(define-syntax (my-or-1 x)
  (syntax-case x ()
    ; Usamos um template variádico
    [(my-or-1 e0 e1 ...)
      #'(if e0
            e0
            (my-or-1 e1 ...))
            ; Reusamos o template variádico com menos 1 argumento.
            ; Como a lista é finita, uma hora a recursão para.
))

Esse comando dá um erro, porque no final não teremos mais como expandir
o my-or-1. Consideremos o exemplo:
                            (my-or-1 #f #t)

O resultado da expansão seria:
(if #f #f (my-or-1 #t))
           ^^^^^^^-- (if #t #t (my-or-1))
                                ^^^^^^^-- Sem argumentos, é desconhecido

Precisamos adicionar uma nova regra ao syntax-case, para quando ele 
tem 0 argumentos.

(define-syntax (my-or-2 x)
  (syntax-case x ()
    [(my-or-2) 
      #'#f]
    [(my-or-2 e0 e1 ...)
      #'(if e0
            e0
            (my-or-2 e1 ...))
))

Poderíamos adicionar um passo a mais, com apenas um argumento. O
anterior já funciona, mas poderíamos adicionar um caso extra: apenas
um argumento, em que o devolvemos.

(define-syntax (my-or-3 x)
  (syntax-case x ()
    [(my-or-3) 
      #'#f]
    [(my-or-3 e0) 
      #'e0]
    [(my-or-3 e0 e1 ...)
      #'(if e0
            e0
            (my-or-3 e1 ...))
))

Nesse caso, naturalmente, nunca entraremos no caso base my-or-3 vazio.
Poderíamos retirá-lo, para dar erro de sintaxe, OU devolver falso nos
casos errados.

Consideremos agora o seguinte exemplo:
(let ([blah #f])
(my-or-3
    (begin ((set! blah (not blah)) blah)
    #f)
)

O resultado expandido será:
(if (begin ((set! blah (not blah)) blah))
    (begin ((set! blah (not blah)) blah))
    (my-or-4 #f))

O valor devolvido seria #f (errado!).

Estamos DUPLICANDO código. Esse é um dos grandes problemas de macros:
replicação desnecessária. E isso ocorre por causa do excesso de lazyness
do código.

Para resolvermos, podemos calcular primeiro, e associar o valor
calculado a um símbolo:

(define-syntax (my-or-4 x)
  (syntax-case x ()
    [(my-or-4) 
      #'#f]
    [(my-or-4 e) 
      #'e]
    [(my-or-4 e0 e1 ...)
      #'(let ([v e0]) ; salva a avaliação em v
          (if v
              v
              (my-or-4 e1 ...))
))

Ainda assim, temos dois potenciais problemas:
* O cálculo do primeiro e0 poderia causar uma mudança de estado - e esta
  não seria passada para o corpo do if. A mudança de estado já estaria
  feita antes, e o resultado poderia ser diferente. Uma outra
  consequência da passagem de estado. O caso do begin acima não era o
  desejado. Porém, se ele fosse, não seria coberto.

* O e0 poderia estar em um environment diferente, e o seu valor estaria
  de forma diferente. Por exemplo:
    
    (let ([e0 #t]) (my-or-4 #f e0))
    
    A expansão seria:
    (let ([v #f])
        if(#f) #f
            (my-or-4 #f))
    
    Nesse caso, estamos CONFUNDINDO o environment externo com o
    environment interno. O valor de e0 usado acaba sendo o de dentro,
    e não o passado de fora.
    
    Bons sistemas de macro não confundem isso, pois usam tabelas
    separadas para valores de argumentos e definições internas de
    símbolos. Essas são chamadas as MACROS HIGIÊNICAS.

=================================================================

MACROS
========

Na aula passada, vimos uma "confusão" dos macros por causa do
environment. A diferenciação entre ambos pode ser desejável para que
possamos fazer definições de macros RECURSIVAS ou com AUTORREFERÊNCIA.

Os macros que evitam esse problema é um MACRO HIGIÊNICO, mas teria esse 
novo problema. A implementação que daria este problema seria:

; Definição de um objeto com autorreferência
; usando a criação via macros.
(define os-1
    (object/self-1
        
        ; Este self dará um ERRO. O processador de macros do Racket
        ; é higiênico. Logo, dentro do macro ele olhará se esse self
        ; foi definido NESTE AMBIENTE. Ele não foi: logo, aparecerá o
        ; erro do self não ser definido.
        [first  (x) (msg self 'second (+ x 1))]
        
        [second (x) (+ x 1)]
))

; Como fazemos isso com macros agora?
(define-syntax object/self-1
  (syntax-rules ()
    [(object [mtd-name (var) val] ...)
        
      ; Primeiro, associamos self com um símbolo qualquer. 
      ; No caso, é um lambda que imprime que está vazio.
      (let ([self (lambda (msg-name)
                    (lambda (x) (error 'object "nothing here")))])
          
          ; Reassocia self com o lambda seletor dos métodos
          (begin 
            (set! self
                  (lambda (msg)
                    (case msg
                      ; O macro cria um lambda usando o nome do
                      ; método, a variável do lambda e o corpo.
                      ; Como pode haver vários métodos, estamos 
                      ; fazendo de forma recursiva
                      [(mtd-name) (lambda (var) val)]
                      ...)))
          self)
      ) ;end let
]))

; O resultado do código expandido seria:
(let ([self 'dummy])
  (begin 
    (set! self
      (λ (msg)
        (case msg
          [(first  (λ (x) (msg self)) )]
          [(second (λ (x) (+ x 1))    )]
)))))

O self do os-1 é marcarado pelo self do object/self-1 quando não deveria.
Uma solução é "arrastar" o primeiro self para dentro da definição,
pré-associando o self:

; Por que esse self não dá problemas quando passado como argumento?
(define os-2
    (object/self-2 self ; O nome do próprio argumento deve ser passado
                        ; como primeiro parâmetro.
                   [first  (x) (msg self 'second (+ x 1))]
                   [second (x) (+ x 1)]))

(define-syntax object/self-2
  (syntax-rules ()
    [(object self [mtd-name (var) val] ...)
        
      ; Primeiro, associamos self com um símbolo qualquer. 
      ; No caso, é um lambda que imprime que está vazio.
      (let ([self (lambda (msg-name)
                    (lambda (x) (error 'object "nothing here")))])
          
          ; Reassocia self com o lambda seletor dos métodos. Agora,
          ; este é o self externo, e estamos afetando a tabela dos 
          ; argumentos.
          (begin 
            (set! self
                  (lambda (msg)
                    (case msg
                      [(mtd-name) (lambda (var) val)]
                      ...)))
            self)
      ) ;end let
]))

(resumo) Mas nem sempre seria desejável passar 'self' como argumento.
Como evitar isso? Poderíamos usar um recurso adicional, suportado pelo
Racket, que permite associar um símbolo DENTRO DA SINTAXE com um DE FORA
DA SINTAXE.  Dessa maneira, uma mudança de estado dentro da macro altera
o espaço das variáveis passadas como argumento para a macro. Assim,
conseguiríamos sobrescrever o self (o que não acontecia na 1ª forma,
pois o self estava em outra tabela de símbolos).

(apostila) O chato disso é que o usuário do macro precisa passar o nome
na definição.
Uma forma de contornar o problema é usar o with-syntax, que é essencialmente
um let para variáveis de sintaxe. Precisamos também poder transformar uma
componente da expressão em sintaxe, o que é feito por datum->syntax.

(define os-3
    (object/self-3
        [first  (x) (msg self 'second (+ x 1))]
        [second (x) (+ x 1)]
))

(define-syntax (object/self-3 x)
  (syntax-case x ()
    [(object [mtd-name (var) val] ...)
      ; associa sintaticamente self com o self passado no argumento
      (with-syntax ([self (datum->syntax x 'self)])
        #'(let ([self (lambda (msg-name)
                        (lambda (v) (error 'object "nothing here")))])
            (begin 
              (set! self
                (lambda (msg-name)
                  (case msg-name
                    [(mtd-name) (lambda (var) val)]
                    ...
              )))
              self
            )
          ) ; let
      ) ; with-syntax
    ] ; definição de objeto
))

Enquanto macros facilitam bastante a construção de linguagens e têm
inúmeras aplicações em outras ferramentas, a inserção direta na
linguagem central é um princípio muito mais eficiente.
Acontece que os compiladores conseguem reconhecer expressões e
otimizá-las. No caso do let, a presença de um lambda que devolve um
lambda que por sua vez deve ser imediatamente aplicado, pode ser
facilmente identificado e trocado por uma extensão do ambiente.

=================================================================

ESTRUTURA CLIENTE SERVIDOR
============================

Controle se refere a controle de fluxo, basicamente desvios e desvios
condicionais. Nos casos extremos, existem coisas parecidas como longjmp
e exceptions. Transferências de controle de uma instrução para seguinte
sempre ocorre, o caso interessante é quando a transferência não é local.
Controle, neste sentido, não aumenta o poder computacional, apenas a expressividade.

Web
O controle em aplicativos distribuídos é particularmente interessante,
pois exite uma dependência grande no protocolo. O http merece estudo à parte.
Considere um servidor web que precisa interagir com o usuário. Normalmente,
um serviço web envia conteúdo estático (páginas ou arquivos), não há como
receber informações. Isto faz sentido, pois o número de usuários é potencialmente
infinito e nem todos completam as tarefas. Como não é possível determinar se a
computação acabou, o protocolo não mantém estado.
Um programa que pergunta 2 números e apresenta sua soma é bastante simples se
tivermos todo o contexto (e estado) disponível:

(define (read-number [prompt : string]) : number
    (begin
        (display prompt)             ; Mostra o prompt
        (let ([v (read)])            ; Lê da stdin e associa a v
            (if (s-exp-number? v)    ; Testa se é número
                (s-exp->number v)    ; Converte para número
                (read-number prompt) ; Se não funcionar, lê outro
                                     ; número
))))

(display 
    (+ (read-number "Fist number")
       (read-number "Second number"))
)

Se estivéssemos numa arquitetura cliente-servidor, este programa simples
de somar NÃO FUNCIONARIA. Você pediria o programa, o servidor enviaria a
pergunta "First number" e, então, acabaria a conexão.

CLIENTE-SERVIDOR COM MEMÓRIA
------------------------------

Precisamos quebrar o programa em DUAS PARTES: o primeiro pedido do
número (requisição 1), e depois executar o pedido do segundo número
(requisição 2). Até termos o segundo número, precisamos GUARDAR o 
primeiro deles.

Uma função que quebrasse poderia ser:

(lambda (v1)
  (display
    (+ v1
      (read-number "Second number"))))

Guardamos v1 no environment do lambda e depois esperamos pelo segundo
número aparecer.

CLIENTE-SERVIDOR SEM MEMÓRIA
------------------------------

Mas essa solução usa memória. Se tivéssemos vários usuários, poderíamos
ter muitos dados armazenados. No pior caso, isso se tornaria um ataque
DDoS (Denial of Service), pois exauriríamos o recurso do servidor.

A comunicação entre cliente e servidor é feita por common gateway interface (CGI),
os famosos formulários (forms) presentes no HTML. Um formulário permite
a entrada de diversos tipos de dados e seu envio por meio de uma action,
associada a um botão especial (submit). Ainda assim, o servidor não tem
como relacionar a solicitação recebida com a anterior.
Uma forma de resolver isso é usar uma tabela para armazenar resultados,
associando uma entrada para cada iteração. Assim, cada resposta a uma
requisição inclui a posição da tabela que contém os dados anteriores.
A tabela pode ser um hash e as iterações podem ser numeradas automaticamente,
com labels sucessivos:

Uma boa solução para contornarmos isso será criar uma ação que se
interrompe, enquanto aguarda pelas respostas dos usuários. Para cada
solicitação teremos um id único. Enviamos para o usuário um formulário
que contém o id da ação a ser realizada. Quando ele enviar os dados, o 
servidor executará a ação.

; retorna o próximo label disponível
(define new-label
  (let ([n (box 0)])
    (lambda ()
      (begin
        (set-box! n (+ 1 (unbox n)))
        (unbox n)))))

; O label para os processos serão números.
; A tabela será um hash vazio
(define-type-alias label number)
(define table (make-hash empty)

Precisamos de uma versão especial do read-number, que armazena na tabela
o que deve ser feito quanto (e se) o resultado chegar. Como ela irá parar
na primeira parte do programa, chamaremos de read-number/suspend. Uma
segunda função, resume, retoma a execução de onde parou.

; A função read-number/suspend apenas pega uma ação "rest" e a carrega
; na tabela de requisições
(define (read-number/suspend [prompt : string] rest)
  (let ([g (new-label)]) ; new-label é uma simples função contadora
    (begin
      (hash-set! table g rest)
      (display prompt)
      (display " To enter it, use the action field label ")
      (display g))))

; Esta ação é a "resposta", que envia o dado solicitado para o servidor.
; Na analogia web, esta seria uma página com FORMULÁRIO, a ser submetido
; ao servidor. Na resposta, teríamos o ACTION-FIELD, o label do hash que
; marca ONDE ESTÁ A AÇÃO A SER EXECUTADA.
(define (resume [g : label] [n : number])
  ((sum-v (hash-ref table g)) n))

Temos os dois passos da chamada web, read-number/suspend faz a primeira
e resume é o tratamento da ação.

========= TODO O PEDAÇO ABAIXO É PARTE DO RESUMO E NÃO DA APOSTILA ========= 

; A ação usando o read-number com suspensão fica:
(read-number/suspend 
  "First number"
  (lambda (v1)
     (display
       (+ v1
         (read-number "Second number"))))
)

; Para um esquema cliente-servidor mais robusto (no caso, que lesse os 
; dois números via este sistema), precisaríamos usar duas solicitações.

A representação das solicitações ficaria:

            Servidor             |              Cliente
=================================|====================================
                                 |            
   . read-number/suspend --------:----- label: 05
   :                             |      form: Mande valor
   :                             |            
   :   table                     |      resume 05 42
   : .----.--------------.       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   '>| 05 | rest         | <-----:-----------'
     |    |  |           |       |            
     |    |  |           |       |            
     '----'--|-----------'       |            
             ^                   |
         read-number             |

ESQUEMA CLIENTE-SERVIDOR COMPLETO
-----------------------------------

Há um problema: o lambda solicitando o v2 pede no servidor (o que não
é realista). Para resolver, basta colocarmos uma solicitação dentro da
outra:

(read-number/suspend 
  "First number"
  (lambda (v1)
    (read-number/suspend 
      "Second number"
        (lambda (v2)
          (display
            (+ v1 v2)
)))))

            Servidor             |              Cliente
=================================|====================================
                                 |            
 ..- read-number/suspend    -----:----- label: 05
 : .-'                 ^    |    |      form: Mande valor
 : :                   |    |    |            
 : :   table           |    |    |      resume 05 42
 : : .----.------------|-.  |    |           |
 : : |    |            | |  |    |           |
 : : |    |  sum       | |  '----:-----------:------ resume 03 0
 : : |    |   ^        | |       |           |            |
 : '>| 03 | rest2      | | <-----:-----------:------------'
 :   |    |            | |       |           |
 '-->| 05 | rest1 -----' | <-----:-----------'
     |    |              |       |            
     |    |              |       |            
     '----'--------------'       |            
                                 |

=================================================================

ARQUITETURA CLIENTE-SERVIDOR
==============================

Em geral, as formas que colocamos na arquitetura da última aula mantém o
ESTADO salvo dentro do hash dos labels. Porém, essa é uma forma, muitas
vezes, pouco eficiente: um usuário pode demorar para responder, ou pode
recarregar uma página web, resolicitar, etc.

Duas soluções, que mantém o estado fora do servidor, são possíveis:
* Manter o estado na aplicação
    Usando variáveis escondidas, que não aparecem numa página web, é
    possível enviar dados e/ou ações pela rede. Este protocolo é SEM 
    ESTADO: o protocolo não muda de acordo com o que está sendo
    transferido. Ele apenas transfere informação de um ponto a outro.
    O estado está nas aplicações (ações feitas), não no protocolo. 
    Nesse caso, não temos uma tabela que armazena dados/ações. O que
    precisa ser feito é enviado dentro do protocolo.
    (Apostila)
    Uma solução é não manter a tabela indefinida, mas ter as funções
    prontas e pré-definidas. A requisição pode escolher apenas uma delas.
    Ainda assim, temos o problema do argumento, mas este pode ficar
    armazenado no cliente (cookies e campos ocultos).

* Manter o estado no cliente
    Usamos o conceito de "cookies". Arquivos disponíveis no navegador 
    do usuário e que um dado site pode editar. Ele o usa para guardar 
    as informações dentro do cliente no momento em que submete um
    formulário para o servidor. O servidor pode, então, usar estes dados
    SALVOS no cliente para continuar as ações.
    
    ; cookies
    (define cookie '-100)
    
    (define (read-number/suspend "\nFirst number (cookie)"
      (lambda (v1)
        (begin
          (set! cookie v1)
          (read-number/suspend "\nSecond number (cookie)"
                               (lambda (v2) (display (+ cookie v2)))
      )))
    ))

    Este é um exemplo de transimissão de informações chamado
    continuation passing style (CPS). Ele consiste, primariamente, de
    quebrar uma ação numa sequência de passos. Dado um passo i, ele 
    executa a computação correspondente a ele e depois envia o restante
    da operação i+1 para ser executada depois.

=================================================================

CONTINUATION PASSING STYLE
============================

(apostila) Esta estratégia de passar a informação para que a computação
possa ser completada (ou continuada) é chamado de estilo de passagem de
continuação (continuation passing style - CPS), ou simplesmente "continuações".
Para tornar mais intuitivo, pense que qualquer computação é um (lambda)
que recebe como argumento o procedimento que deve ser aplicado ao resultado
da computação que é feita em seu corpo. Este argumento é a continuação.
O método é transformar funções de um argumento (não todas, apenas as que
envolvem interação remota) em outra função com dois argumentos. O segundo
argumento é uma função que executa o resto do processamento: a continuação.
Um exemplo interessante é um jogo de xadrez por correio convencional: o jogador
manda uma carta com sua jogada e o desenho atual do tabuleiro.
Esta tranformação é geral, pode ser aplicada em qualquer programa e não
altera a semântica. Por isso é chamado de estilo. Por ser uma transformação
da linguagem na própria linguagem, pode ser vista como uma espécie de açúcar
(ou desugar). Como consequência, o interpretador da lingaugem pode também
interpretar as continuações.

Este método de computação é o utilizado dentro do esquema
cliente-servidor (mesmo com suas várias formas de manter o estado). O
conceito chave é quebrar uma certa computação em uma série de passos
menores, em que vamos mantendo o "resto" da computação depois da
operação.

Ex:
    ; Toda expressão CONSTANTE deve ser quebrada na forma:
    ; * Constantes cte:
    ; (λ (resto) (resto cte) )
    
    - Original:
    (+ 2 2)
    
    - CPS:
    (
        (λ (resto) (resto 2))
        (λ (x) (+ x 2))
    )

Ex:
    ; Todo LAMBDA deve ser quebrada na forma:
    ; * Lambdas (λ (arg) (ação arg)):
    ; (λ (arg resto) (resto (ação arg)) )
    
    - Original:
    ((λ (a) (+ (* a 2) 5)) 2)
    
    - CPS:
    (
        ; Criamos um lambda com a computação mais interna, (* a 2)
        ; que é depois aplicada no "resto" da ação.
        (λ (a, resto) (resto (* a 2)))
        
        ; O argumento para este lambda são dois valores: o x e o resto.
        (2 (λ (x) (+ x 5)))
    )

Para cada tipo de estrutura, quebraríamos de forma diferentes. Essa é
uma forma de TRANSFORMAÇÃO, em que estamos modificando o programa SEM
alterar o resultado. A implementação poderia ser feita de duas formas:
* Açúcar : Usando macros para transformar as sentenças originais;
* Core   : Modificar o core para implementar esta forma.

Se pegássemos uma expressão, teríamos a transformação na forma:
e:    3 * (5 + 2) - 7 * 4
f(x): 3 * x - 7 * 4         e = f(5+2)
g(y): y - 7 * 4             e = g(f(5+2))
...                         ...

Estamos passando o resultado de uma ação para a próxima. Essa é a ideia
de PILHA DE EXECUÇÃO, como feita em Assembly. Cada ação devolve apenas
uma modificação de estado, e o estado é compartilhada pelas várias ações
necessárias para serem feitas.

=================================================================

MACROS PARA CPS
=================

Vamos criar um processador de macros para o estilo de processamento de
continuação. Com ele, transformaremos um tipo de expressão em outra.

Faremos uma conversão de sintaxe. Escreveremos com nosso estilo, e a
traduziremos com os comandos tradicionais do Racket para o estilo de 
continuação.
    
              |  Sintaxe CPS  |    Racket    |
              |===============|==============|
              | with          | let          |
              | rec           | letrec       |
              | lam           | lambda       |
              | cnd           | if           |
              | set           | set!         |
              | seq           | begin        |

(define-syntax (cps e)
  (syntax-case e (with rec lam cnd seq set quote display read-number)
    
    ; símbolo
    [(_ atomic)
        #'(lambda (k) (k atomic))]
    
    ; Rec é como o let recursivo (letrec), que muda o storage
    ; conforme novas associações são feitas
    [(_ (rec (v f) b))
        #'(cps (with (v (lam (arg) (error 'dummy "nothing")))
                  (seq
                    (set v f)
                    b)))]
    
    ; lambda
    [(_ (lam (a) b))
      (identifier? #'a)
      
      ; Toda sintaxe convertida deve ser um lambda que recebe como
      ; parâmetro uma continuação. Essa continuação, definida no 
      ; tempo de definição da função, chama-se k. O corpo da função,
      ; seja qual for, deve ser argumento para esta continuação.
      #'(lambda (k)
          
          ; Todo argumento devolvido por uma função também deve 
          ; estar no CPS. Precisamos converter o λ de verdade para
          ; esse estilo. Para fazer isso:
          ; 1. Expandimos a lista de argumento para receber como 
          ;    argumento final uma continuação: dyn-k
          ; 2. O corpo também precisa ser passado para o estilo de
          ;    continuação. Isso pode ser feito aplicando a 
          ;    continuação dyn-k para ele.
          ;
          (k (lambda (a dyn-k) ((cps b) dyn-k) ))
        )
    ]
    
    ; Ex:
    ; (λ (a) b)
    ; (λ (k) 
    ;    (k (λ (a dyn-k) (eps b dyn-k)))
    ; )
    ; 
    ; Ex:
    ; (cps (+ (rn "um") (rn "dois")) )
    ; ( 
    ;     (λ (k) 
    ;        (+ k (rn "dois"))
    ;     )
    ;     (rn "um") 
    ; )
    
    ; chamada com 1 argumento
    [(_ (f a))
     #'(lambda (k)
         ((cps f) (lambda (fv)
                    ((cps a) (lambda (av)
                               (fv av k))))))]
    
    ; chamada com 2 argumentos
    [(_ (f a b))
        ; Pegamos uma aplicação de função, com dois argumentos.
        ; Ela tem uma continuação
        #'(lambda (k)
           ; Interpretamos 'a' e passamos como continuação para 
           ; ele o segundo argumento
           ((cps a) (lambda (av)
                      ; Interpretamos 'b' e passamos como continuação para
                      ; ele a funçaõ aplicada a ambos os argumentos
                      ((cps b) (lambda (bv)
                                 (k (f av bv)))))))]
    ; with é como o let
    [(_ (with (v e) b))
     #'(cps ((lam (v) b) e))]

    ; cnd é o if
    [(_ (cnd tst thn els))
     #'(lambda (k)
         ((cps tst) (lambda (tstv)
                      (if tstv
                          ((cps thn) k)
                          ((cps els) k)))))]

    ; set é o mesmo que set!
    [(_ (set v e))
     #'(lambda (k)
         ((cps e) (lambda (ev)
                    (k (set! v ev)))))]

    ; begin para 2 expressões
    [(_ (seq e1 e2))
     #'(lambda (k)
         ((cps e1) (lambda (_)
                     ((cps e2) k))))]

    ; display - definido internamente
    [(_ (display output))
     #'(lambda (k)
         ((cps output) (lambda (ov)
                         (k (display ov)))))]

    ; read-number 
    [(_ (read-number prompt))
     #'(lambda (k)
         ((cps prompt) (lambda (pv)
                         (read-number/suspend pv k))))]
))

========= PARTE DO RESUMO E NÃO DA APOSTILA =========

; Continuação "identidade", para não fazermos nada na última continuação
(define identity '(lambda (c) c))

; Açúcar sintático para rodar expressões feitas na linguagem
; de escrita de continuações. Ele pega uma continuação e passa
; como continuação final para ela a identidade, que fará a última
; ação parar a recursão.
(define (run [k : s-exp]) (k identity) )

Exemplo de expansão
---------------------

(cps (display (+ (rn "f") (rn "s"))) )

(λ (k) ( (cps (+ (...) (λ (ov (k (display ov))))))
         (λ(k) ( (λ (k2) ((cps (rn ...) 
                            (λ (av) (cps ((rn "s"))
(λ (bv) (k2 (f av bv))))))))))

========= FIM DA PARTE DO RESUMO QUE NÃO ESTÁ NA APOSTILA =========

=================================================================

Continuation Passing Style
============================

Um exemplo simples de CPS possível seria fazer a soma passo a passo:
(+ a b)

(λ (k) ((cps a) (λ (av) ((cps b) (λ (bv) (k (+ av bv)))))))
        ^^^^^^^    ^^^^  ^^^^^^^    ^^^^    ^^^^^^^^^
          (1)       (2)    (3)       (4)       (5)

1) Primeiro, calculamos o argumento 'a' da soma. O resultado será um
   lambda que aceita uma continuação;
2) O valor calculado em 'a' será passado para a continuação - e salvo
   no lambda com a associação de do da computação com av;
3) A continuação começa calculando o argumento 'b' da soma. O resultado
   será um lambda que aceita uma continuação;
4) O valor calculado em 'b' será passado para a continuação - e salvo
   na lambda com a associação do resultado da computação com bv;
5) Usando 'av' e 'bv', realizamos a última computação (somar av com
   bv, o primeiro salvo no environment desse lambda). O resultado deve
   ser aplicado na continuação global da expressão: k.

Se quiséssemos apenas EXECUTAR, então poderíamos executar esta
continuação passando 'k' como a função identidade.

=================================================================

CPS MONTADO NO CORE
=====================

(apostila)
Para implementar no core, basta fazer interp trabalhar com continuações,
o que é compatível com o fato de continuações ser um estilo de execução.
É só construir um interp/k aplicando as transformações da seão anterior
no interp. O único cuidado é que precisamos mudar o Value, já que agora
closV passa a ter dois argumentos.

Como poderíamos fazer para alterar a nossa última linguagem, de modo a
criar CPS? Simples: a partir da árvore, vamos interpretá-la construindo
estruturas em CPS. Precisaremos passar, a cada uma das interpretações,
qual é a CONTINUAÇÃO.

(define-type Value
    [numV  (n : number)]
    
    ; Nosso valor é uma função:
    ; 1. Que tem como domínio um valor com dois argumentos:
    ;    1.1 Um valor
    ;    1.2 Uma função de Valor em Valor
    ; 2. Que tem como imagem um valor
    ;
    [closV (f : (Value (Value -> Value) -> Value))]
    ;           |(1.1)      (1.2)           (2)  |
    ;           |                                |
    ;           '-------------- (1) -------------'
)

(define (interp/k [expr : ExprC] [env : Env] [k : (Value -> Value)]) Value
  (type-case ExprC expr
    [numC (n)   (k (numV n))]
    [idC (n)    (k (lookup n env))]
    
    ; Precisamos:
    ; 1. Calcular o valor de f (intepretar a expressão f). Passamos
    ;    o environment corrente + uma continuação.
    ; 2. Armazenar o resultado de f, guardando esse valor num λ
    ; 3. Calcular o valor de a (interpretar a expressão a). Passamos
    ;    o environment corrente + uma continuação.
    ; 4. Guardamos o valor interpretado de a em f
    ; 5. Por último, aplicamos a closure, passando:
    ;    5.1. av como argumento principal
    ;    5.2. k como continuação, para computar o restante
    [appC (f a) (interp/k f env (lambda (fv)
                                  (interp/k a env
                                    (lambda (av) (closV-f fv) av k)
                                )))
    ]
    
    ; Não precisamos passar uma continuação com num+. Como ele não faz
    ; mais nada - ele é um caso básico - não precisamos passar o k para 
    ; lá. Numa função qualquer, que poderia ter mais chamadas de
    ; funções, precisaríamos PASSAR esta continuação porque a função
    ; vai para o outro lugar.
    [plusC (l r) (interp/k l env (lambda (lv) 
                   (interp/k r env (lambda (rv) 
                     (k (num+ lv rv))
                   ))
                 ))
    ]
    
    ; Análogo ao caso acima
    [multC (l r) (interp/k l env (lambda (lv) 
                   (interp/k r env (lambda (rv) 
                     (k (num* lv rv))
                   ))
                 ))
    ]
    
    ; Análogo aos casos acima
    [ifC (c y n) (interp/k c env (lambda (cv)
                   (if (zero? (numV-n cv))
                     (interp/k n env (lambda (nv) (k nv)))
                     (interp/k y env (lambda (yv) (k yv)))
                 )))
    ]
    
    ; No lambda, o processo segue os mesmos princípios:
    ; 1. Nosso valor de retorno será um closV, que recebe como 
    ;    argumento uma função de Valor em Valor
    ; 2. A função criada terá dois argumentos: um valor de argumento
    ;    (o argumento tradicional) e uma nova continuação (dyn-k). 
    ;    NÃO usamos k, pois ele é uma continuação na construção de
    ;    expressões. Caso nossa interpretação final tivesse como 
    ;    valor de retorno apenas um lambda, por exemplo, teríamos
    ;    um lambda que está no estilo CPS.
    ; 3. O corpo do lambda será a conversão para o estilo CPS
    ;    (interpretação) do argumento 'b'. Ele deverá ter como
    ;    environment o environment EXTENDIDO com a associação de 
    ;    'a' a 'arg-val'. Essa interpretação, porém, deverá ocorrer
    ;    sobre a continuação dyn-k.
    [lamC (a b) (k (closV (lambda (arg-val dyn-k)
                            (interp/k b
                              (extend-env (bind a arg-val) env) dyn-k))
    ))]
))

O interpretador muda pouco:
; disparador
(define (interp [expr : ExprC]) : Value
  (interp/k expr mt-env (lambda (id) id)))

; facilitador
(define (interpS [s : s-expression]) (interp (desugar (parse s))))

; testes
(test (interp (plusC (numC 10) (appC (lamC '_ (numC 5)) (numC 10))))
      (numV 15))

(interpS '(+ 10 (call (func x (+ x x)) 16)))

=================================================================

GERADORES
===========

(apostila)
A noção de gerador discutida aqui é mais abrangente do que normalmente
se encontra nas descrições de linguagens. Normalmente, um gerador é uma
função que retorna uma parte do resultado por vez. Por exemplo, gerando
uma lista elemento por elemento. Pense em um iterador do Java.
Em uma formulação mais geral, um gerador (generator) é uma função que
quando é chamada novamente, recomeça da última posição onde parou. Isto
naturalmente significa que a função deve poder sair antes do final, um
"return" temporário. Em inglês, isso é chamado de yield, que não possui
tradução direta em português, significa algo como "repassar", "dar a
preferência", "abrir mão" ou "passar a vez": a função retorna o controle
do processamento para quem chamou. Na próxima chamada, ou reentrada, o
controle volta para o ponto onde o yield foi feito.

Geradores são lambdas que interrompem sua execução, e, ao serem chamadas
novamente, continuam do ponto em que tinham parado.

Em orientação a objetos, temos um método que realiza uma ação como a de
um gerador: o iterador - que retorna o próximo elemento de algum tipo de
ação.

Em Python, existe suporte para geradores: o comando 'yield'

>>> def f() :
...    n = 0
...    while n >= 0 :
...        yield n
...        n += 3
>>> g = f()
>>> g.next()
0
>>> g.next()
3
>>> g.next()
6
>>> g.next()
9

(apostila)
Em algumas linguagens, um gerador é um objeto: iteradores do Java, já citados,
são um exemplo. Em Python, um gerador possui o comando yield no seu corpo. Em
Racket e outras linguagens similares, yield não é um comando, mas um procedimento
passado como argumentp (chamado de applicable, ou aplicável). Existem algumas
coisas curiosas. Em algumas linguagens, o nome do yielder é forçosamente yield.
Em Python está pré-definido. Em Racket, o nome associado (bound) ao procedimento
tem que ser yield. OUtro ponto é se yield deve ser um comando ou um procedimento.
A segunda opção é naturalmente mais flexível.
Uma última questão é como o gerador avisa que terminou seu processamento. Pode
retornar um valor especial ou gerar um sinal (exceção).

Existem várias opções para implementar geradores:
1) Usando orientação a objetos (como via interfaces, em Java)
2) Usar uma fábrica de geradores, que funciona para qualquer lambda
3) Usar CPS (Continuation Passing Style) para a implementação

Nossa implementação usará:
- CPS (Continuation Passing Style)
- Retomada direta (sem o 'next')
- yield é um procedimento
- erro/exceção no final da execução

Um gerador possui dois comportamentos: na sua chamada e quando retorna o controle.
As situações são estas e o gerador deve (note a dualidade):

    .----------------------------------------------------------.
    |                          GENERATOR                       |
    |------------------------------.---------------------------|
    |     Entrada (chamada)        |       Saída (yield)       |
    |------------------------------|---------------------------|
    | lembrar ONDE está quem chama | saber para ONDE retornar  |
    |------------------------------X---------------------------|
    | saber ONDE deve prosseguir   | lembrar ONDE parou        |
    '------------------------------'---------------------------'

(apostila) As ocorrências das palavras "onde" correspondem às continuações.

As nossas continuações estão nos "ONDE" de todas as entradas e saídas:
saber o que virá em seguida é nossa continuação.

Quando entramos em um generator, salvamos a continuação da ação que
chamou o generator. Quando chegamos no yield, precisamos salvar o 
ponto do código em que estamos (para continuar na próxima chamada) 
e retornamos para a continuação de quem chamou a função. Na próxima
chamada, começaremos pelo Generator.

(define-syntax (cps e)
  (syntax-case e (generator with rec lam cnd seq set quote)
    ; O _ representa o nome o gerador de macros (cps)
    ; 
    ; Essa estrutura estará dentro do cps
    ; Toda vez que encontrarmos 'generator', teremos 3 argumentos
    ; 1. Função 'yield' que fará a interrupção
    ; 2. Valor para o generator (será apenas 1, por simplicidade)
    ; 3. Corpo da função com ações a serem realizadas
    ;
    [(_ (generator (yield) (v) b))
        
        ; Predicado: teste para ver se a conversão é válida
        (and (identifier? #'v) (identifier? #'yield))
        
        ; CPS transformado: nossa continuação com algo a mais
        #'(lambda (k) (k 
            ; Aqui está o nosso gerador: usaremos um let recursivo
            ; para podermos chamar as várias funções
            (letrec (
                [where-to-go 
                    ; A função where-to-go só é um auxiliar inicial,
                    ; para que apresentemos uma mensagem de erro no
                    ; caso de não termos nenhum yield no começo
                    (lambda (v) (error 'where-to-go "nothing"))
                ]
                [resumer
                    ; A função resumer é a responsável por executar
                    ; o corpo do generator. Como ele está em CPS, 
                    ; quando terminarmos de executá-lo, deveremos 
                    ; "sair" da função com uma exceção.
                    ;
                    ; Esta definição de resumer será sobrescrita 
                    ; ao chamarmos um yield dentro do corpo. Porém,
                    ; a execução inicial do corpo, em cps, com a 
                    ; continuação sendo o erro, já está feita.
                    ;
                    (lambda (v) (
                        (cps b) (lambda (v)
                        (error 'generator "passou dos limites"))
                    ))
                ]
                [yield
                    ; Nossa função yield deve ser chamada de dentro
                    ; do corpo da função. Ela está em CPS, e por isso
                    ; tem um argumento e uma continuação (gen-k). 
                    ; 
                    ; Como resumer está salva dentro do ambiente do
                    ; letrec, podemos sobrescrevê-lo usando o set.
                    ; O novo resumer será a continuação do generator.
                    ; 
                    ; Quando chamarmos o lambda na segunda execução,
                    ; 'resumer' fará com que a nossa função comece 
                    ; em gen-k: justamente o que queríamos - o 
                    ; programa partir da continuação.
                    ; 
                    (lambda (v gen-k) (begin
                        (set! resumer gen-k)
                        (where-to-go v)
                    ))
                ]
            
            ); fim do letrec
                
                ; Quando executamos nossa função, setamos qual será
                ; a continuação ao acabarmos esta rodada do lambda.
                ; Uma vez feito isso, executamos 'resumer'
                ; (apostila) O núcleo do gerador deve armazenar estes estados:
                (lambda (v dyn-k)
                       (begin
                           (set! where-to-go dyn-k)
                           (resumer v)
                ))
            )
        ))
    ]
    
    ... ; os outros comandos definidos mais acima (with, rec, lam, ...).
        ; Estão algumas linhas/páginas acima
))

Resumindo o passo-a-passo da construção do generator:
1. Nosso generator é um lambda em CPS. Deverá ter um argumento (v) e 
   uma continuação (dyn-k). Ele salva o dyn-k no storage e aplica
   a função resumer com argumento 'v'.

2. A primeira versão de resumer é simples: chama o corpo 'b' que 
   (definido na implementação generator) com o valor 'v'. Como 
   'b' está em CPS, ele precisa de continuação. Conforme nossa 
   definição inicial, ao acabar de executar devolveremos uma 
   exceção (que nada mais é que um lambda).

3. Dentro do corpo, pode haver chamadas de 'yield'. O 'yield' 
   é um lambda em CPS que recebe um argumento e uma continuação.
   A continuação é o trecho de código que, em Python, vem logo 
   após o 'yield'. Como as funções 'where-to-go', 'yield' e 
   'resumer' estão salvas dentro do mesmo letrec, podemos alterar
   o storage associado a esses símbolos. Por isso, 'yield' 
   sobrescreve 'resumer' para ser esta continuação.

4. Daí para frente, a execução continua, nesse processo de substituição
   de 'resumer' por 'yield' e execução das continuações.

(Na apostila, ainda tem as sessões "Continuações e a pilha de execução",
"Recursão de cauda", "Recursão como uma característica da linguagem",
"Continuações em Racket" e "Threads", o que tomam ~6.5 páginas)

=================================================================

TIPOS
======

De forma geral, quando temos expressões, não temos como saber se o
resultado será válido ou não. Em alguns casos, teremos erro certamente.
Em outros, sempre funcionará. No terceiro caso, não teremos como saber
até o tempo de execução.

Por esse motivo, existem os tipos. Eles permitem que verifiquemos a 
validade de algumas expressões ainda antes da execução. Por exemplo:
* [XX] (+ 3 (λ (x) x)) 
  Sempre será errada, porque não conseguimos somar função e número.
* [OK] (let ([f (λ (x) (+ x 1))]) (+ 3 (f 5)) )
  Teremos necessariamente um número retornado na aplicação de f,
  e o programa funcionará.
* [XX] (let ([f (λ (x) (λ (y) (+ x y)))]) (+ 3 (f 5)) )
  F devolverá sempre uma função, e não funcionará.
* [??] (λ (f) (+ 3 (f 5)))
  O resultado só poderia ser visto em tempo de execução, pois
  depende do argumento f.
* [??] (+ 3 (zero? (read-number) 5 (λ (x) x)) )
  Nesse caso, não teríamos nenhuma maneira de verificar o tipo
  até que ocorresse a execução.

Cada linguagem lida com esses diversos problemas de formas diferentes.
Algumas, como o Racket padrão, Python ou Perl não verificam de forma
alguma. Uma opção é verificar tipos em tempo de execução, o que causaria
um overhead muito grande. De outras maneiras, poderíamos ter problemas.

Tipo
|--> Conjunto dos valores
'--> Qualquer propriedade verificável sem a necessidade de executar
     o programa.

* Essa definição de tipos mostra que nem sempre é possível verificá-los.
  Caso conseguíssemos testá-los em todos os casos, estaríamos resolvendo 
  o problema da parada de Turing (que é indecidível, o que nos mostra
  que nem sempre é possível).
* Expressões estão associadas a tipos que devem ser consistentes.

* Desvantagens da tipagem
    - Perda de flexibilidades (aumenta as restrições)
    - Pode aumentar o custo computacional
    - Exige anotação do programa
    - Problema de computabilidade
* Possíveis vantagens
    - Evita tempo de depuração (diminui erros de execução)
    - Captura erros em trechos não executados
    - Documentação (os tipos, por si próprios, conseguem mostrar
      o que uma função recebe e retorna)
    - Auxilia o compilador (permite otimizações voltadas 
      a um dado tipo)
    - Força um código mais elegante (padronizado)

SISTEMA DE TIPOS
==================

Existem três elementos essenciais para implementar um sistema de tipos:
1) Coleção de tipos
2) Um julgamento: valor ↔ tipo ? (sistema formal)
3) Um algoritmo para o julgamento

* Cada expressão tem uma regra:
    { n         : número
    { (λ (a) b) : função
    Essas associações são mantidas num ENVIRONMENT DE TIPOS (Γ)

* Julgador
    Γ  ⊢  n         : Número
    Γ  ⊢  (λ (a) b) : Função
    Partindo dos axiomas em nossa teoria (Γ), conseguimos provar por
    meio de regras de dedução que algo pertence a um tipo.

* Faremos as representações usando a seguinte forma:
    procedentes
    -----------  Numa forma parecida com o método de prova da 
    conclusões   dedução natural
    
    Usaremos a seguinte notação:
    * Γ         : ambiente de tipos (associações)
    * Γ ⊢       : julgador
    * τx        : tipo de x
    * Γ[x ← τ1] : ambiente estendido
    * ∅         : ambiente vazio
    
    Γ ⊢ l : num  Γ ⊢ r : num  
    ------------------------  Regra de dedução natural para a SOMA
       Γ ⊢ (+ l r) : num      
    
    Γ ⊢ f : func  Γ ⊢ a : τa } Agora, não temos como deduzir o tipo
    ------------------------ } de retorno apenas sabendo que f é do
        Γ ⊢ (f a) : ?        } tipo função
    
    Γ ⊢ f : τa → τb  Γ ⊢ a : τa  } Regra de dedução natural para a 
    ---------------------------  } APLICAÇÂO DE FUNÇÃO
           Γ ⊢ (f a) : τb        } Na função, precisamos da notação
                                       domínio → contradomínio
    
    Γ[a ← τ1] ⊢ b : τ2 } Regra de dedução natural para a DEFINIÇÃO
    ------------------ } DE FUNÇÃO
    Γ ⊢ (λ (a) b) : τ2 } Nossa teoria estendida, com a hipótese de que
                         a é do tipo τ1, prova que b é do tipo τ2. 
                         Nesse caso, o lambda retorna τ2.
    
    Γ ⊢  c : boolean  Γ ⊢ y : τ1  Γ ⊢ n : τ2 } Se tivermos argumentos
    ---------------------------------------- } de tipos diferentes no 
              Γ ⊢ (if c y n) : ?             } if não teríamos como 
                                               diferenciar para a 
                                               dedução
    
    Γ ⊢  c : boolean  Γ ⊢ y : τ1  Γ ⊢ n : τ1 } Regra de dedução natural
    ---------------------------------------- } para o IF
               Γ ⊢ (if c y n) : τ1           } 

* Exemplos:
    - (+ 2 (+ 5 7)) 
      ; Soma simples (funciona)
    
        ∅ ⊢ 2 : num  ∅ ⊢ 5 : num  ∅ ⊢ 7 : num
                     ------------------------
                        ∅ ⊢ (+ 5 7) : num
        -------------------------------------
              ∅ ⊢ (+ 2 (+ 5 7)) : num
    
    - (+ 3 (λ ([x : num] : num x))) 
      ; Soma com função (não funciona)
    
        ∅ ⊢ 3 : num   (λ ([x : num] : num x)) : num → num
        --------------------------------------------------
                ∅ ⊬ (+ 3 (λ ([x : num] : num x)))
        
        Não está definido uma regra de soma de num → num
    
    - Laço infinito com combinador-Y
      
      (                    (                    (
        (λ (x) (x x))  →     (λ (x) (x x))  →     (λ (x) (x x))  →  ...
        (λ (x) (x x))  →     (λ (x) (x x))  →     (λ (x) (x x))  →  ...
      )                    )                    )
      ^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^^^      ^^^^^^^^^^^^^^^
        1ª Iteração          2ª Iteração          3ª Iteração
    
      ω : τa → τω      } Para descrevermos essa recursão infinita
             τa → τρ   } (pelo uso do combinador-Y), precisaríamos
                   ... } de uma dedução infinitamente longa.
      
      Caso essa lista fosse finita, seria possível provar que o 
      programa para. Mas se o programa sempre parar, então resolvemos
      o Problema da Parada. Isso é impossível, pois o problema é 
      indecidível. Então essa linguagem que usamos NÃO É CAPAZ de 
      descrever esse laço infinito.
      
      Para suportarmos a existência de recursão, precisaremos criar
      uma regra que use lazyness:
      
      Γ[i ← τi] ⊢ b : τ  Γ[i ← τi] ⊢ v : τi
      -------------------------------------
           Γ ⊢ (rec (i : τi v) b) : τ
      
      O "rec" é o lambda que faz a construção de recursão - seja via
      combinador-y ou por manutenção do estado. Ele precisa de dois
      argumentos: o primeiro, uma lista que contenha o SÌMBOLO A 
      SER USADO PARA A CHAMADA RECURSIVA (i) com A FUNÇÃO USADA PARA
      GERAR A RECURSÃO (v); o segundo, o CORPO DA FUNÇÃO (b).
      
      O argumento "i" precisa ser do mesmo tipo do v, porque 
      será associado a ele dentro da implementação recursiva. 
      Também, usando a associação de 'i' com seu tipo, precisamos
      provar que o corpo retornará τ.
      
* Podemos resumir as regras como sendo:
    
    .===============.==========================================.
    |   OPERAÇÂO    | REGRA                                    |
    |===============|==========================================|
    |  +,-,*,/      | Γ ⊢ l : num  Γ ⊢ r : num                 |
    |               | ------------------------                 |
    |               |    Γ ⊢ (+ l r) : num                     |
    |===============|==========================================|
    | (λ (a) b)     | Γ[a ← τ1] ⊢ b : τ2                       |
    |               | ------------------                       |
    |               | Γ ⊢ (λ (a) b) : τ2                       |
    |===============|==========================================|
    | (f a)         | Γ ⊢ f : τa → τb  Γ ⊢ a : τa              |
    |               | ---------------------------              |
    |               |        Γ ⊢ (f a) : τb                    |
    |===============|==========================================|
    | (if c y n)    | Γ ⊢  c : boolean  Γ ⊢ y : τ1  Γ ⊢ n : τ1 |
    |               | ---------------------------------------- |
    |               |            Γ ⊢ (if c y n) : τ1           |
    |===============|==========================================|
    | (rec (i v) b) | Γ[i ← τi] ⊢ b : τ  Γ[i ← τi] ⊢ v : τi    |
    |               | -------------------------------------    |
    |               |     Γ ⊢ (rec (i : τi v) b) : τ           |
'==============='=========================================='
