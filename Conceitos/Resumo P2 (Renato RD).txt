HOSPEDEIRO
============

Quando construímos nossa linguagem, criamos vários níveis:
1) Linguagem "Açucarada" (Sugar);
2) Linguagem Central     (Core);
3) Linguagem Hospedeira  (Racket);

Ao desenvolvermos uma linguagem, de forma geral, utilizamos alguma
plataforma/linguagem "hospedeira", sobre a qual a nova linguagem 
será feita. No caso de linguagens compiladas, ela pode ser a própria
máquina ou máquinas virtuais. No caso de linguagens interpretadas, é
a linguagem na qual foi feito o interpretador.

Quando definimos o valor, tínhamos:
(define-type Value
    [numV  (n : number)]
    [closV (a : symbol) (b : body) (e : env)]
)

numV usa todos os tipos do Racket (hospedeiro), a fim de facilitarmos
a construção da linguagem - já que ela suporta inteiros, ponto
flutuante, complexos e frações. Será que poderíamos usar também o
outro tipo - a closure - para fazer isto?

Sim! E as modificações são simples:

* Primeiro, no Value:
(define-type Value
    [numV  (n : number)]
    ; A closure será a própria closure do Racket.
    ; Ela simplesmente pega um valor e o retorna.
    ; O argumento e o ambiente estão implicitamente 
    ; salvos dentro do próprio lambda.
    [closV (f : (Value -> Value)]
)

* Em segundo lugar, no interpretador:
    [lamC (a b) (closV (lambda (arg-val)
                    (interp
                        (extend-env (bind a arg-val)
                            (

Estamos implementando uma linguagem funcional - subconjunto do 
Lisp/Scheme/Racket - numa linguagem funcional. E, por esse motivo,
podemos delegar muito para a linguagem hospedeira. Mas isso pode
trazer vantagens e desvantagens:

* Se tivéssemos uma linguagem hospedeira e DE SUPERFÍCIE (central)
 diferentes, muitas dificuldades poderiam existir. Por exemplo: 
    - Se a linguagem de superfície tivesse lazyness, e a linguagem
      hospedeira, eager, uma execução válida no ambiente lazyness
      poderia ser inválida no contexto eager;
    - Esse problema traz outro: as mensagens de erro, válidas numa
      linguagem (por exemplo, divisão por 0 executada na eager, mas
      não executada na lazy) poderia não ser na outra. Tanto da 
      hospedeira para a de superfície, como vice-e-versa.

* A dependência da linguagem hospedeira pode QUEBRAR a linguagem
  de superfície, se as características da hospedeira se alterarem
  com o tempo.

ENVIRONMENT COM LAMBDAS
=========================

Fizemos a alteração de trocar os closV de implementação de forma
prática para uma implementação usando o hospedeiro Racket.

Em nossa linguagem, toda a parte de Environment estava encapsulada.
Como seria possível trocar o Environment como lista de associações
e usar lambdas?
    
Definindo formalmente:
    Env     -> λ (symbol -> Value)
    mt-env  -> λ ERRO
    
O environment, para cada símbolo, nos devolverá um valor. Por outro
lado, mt-env deverá retornar um ERRO, dado um símbolo - pois ao tentar
achar qualquer coisa num environment vazio, sempre haverá nada para
retornar.

Então:
(define (mt-env [name : symbol])
    (error 'lookup: did not find')
)

; Temos aqui duas closures: uma do extend-env, que recebe dois
; argumentos (binding e o environment), e o lambda que será retornado.
; 
; Ao criarmos este novo lambda, temos uma closure - o binding 'b' e
; o environemnt 'e' na função na qual estão inseridas ficam armazenadas
; no ENVIRONMENT DO CLOSURE DO RACKET. Toda vez este lambda, 
; representando o Environment, tiver um símbolo, ele busca no 
; seu próprio binding. Caso contrário, ele busca no environment que
; existia quando ele foi criado.
; 
; Esquematicamente, os environments mais complexos são:
;
; ..........................    
; .....................    |    
; ................    |    |    Temos, aqui dentro, a nossa 
; ...........    |    |    |    "LISTA DE ASSOCIAÇÕES". Porém,
; ......    |    |    |    |    ela está MASCARADA dentro das
; |    |    |    |    |    |    chamadas recursivas dos lambdas
; | b1 | b2 | b3 | b4 | b5 |    do Racket. Para um dado environment
; |    |    |    |    |    |    e, o binding b1 e o environment e1
; '....'    |    |    |    |    com os quais ele foi construído
; ..........'    |    |    |    estão guardados DENTRO do environment
; ...............'    |    |    do próprio closure.
; ....................'    |    
; .........................'    
; 
(define (extend-env [b : Binding] [e : Env])
    (λ ([name : symbol]) : Value
        (if (symbol=? name (bind-name))
            (bind-val b)
            (lookup name e)
)))

(define (lookup [name : symbol] [e : Env]) (e name))

=================================================================

AÇÚCAR
========

O processo de construção de açúcar permite transformar uma sintaxe 
em outra:
            sintaxe A ----------------------> sintaxe B
                                               (core)

O primeiro exemplo que utilizamos para açúcar sintático foi:
        (let (var val) body) --> ((λ (var) body) val)

Mas assim como conseguimos criar regras de açúcar diretamente na 
linguagem açucarada, também poderíamos fazê-lo EM TEMPO DE INTERPRETAÇÃO
(on the fly).

No Racket, existe essa opção, por meio dos comando:
    (define-syntax macro regra)
                         ^^^^^- { syntax-rules
                                { syntax-case

Criaremos um "novo let". Para que o próprio Racket não se confunda, 
usaremos o nome "my-let" com números 1,2,... para eles.

(define-syntax my-let-1
    (syntax-rules () ; arg para definir associações locais às regras
        
        ; Lista de regras de tradução
        [(my-let-1 (var val) body) ((lambda (var) body) val)]
        
        ; Cada uma das regras trabalha como MACRO - nenhuma 
        ; modificação é criada e só se traduz de um para outro.
))

Podemos aceitar argumentos como listas de qualquer tamanho, usando
o símbolo "...". Ele funciona como os TEMPLATES VARIÁDICOS do C++ 
ou as funções com múltiplos argumentos do C:

                    ..----------------------------..-------------..
                    \/                            /\             /\
         Constroi 'n' pares (var val)       Pega 'n' vars  Pega 'n' vals
                _____________                 _________       ________
    [(my-let-2 [(var val) ...] body) ((lambda (var ...) body) val ...)]

O Dr. Racket tem a opção MACRO-STEPPER, que mostra qual o resultado das
EXPANSÕES DE MACROS criadas pelo define-syntax. Entretanto, nem sempre
o resultado pode ser o esperado, pois o Racket pode OTIMIZAR os
argumentos variádicos para seus próprios lambdas.

PROBLEMAS
-----------

Os macros são interessantes, mas podem gerar problemas parecidos com as
macros de C/C++: os erros não são checados quando definimos as novas
regras sintáticas. Por exemplo

* Racket                          | * C/C++
                                  | 
; Em vez de um símbolo para       | // Definição do Macro em C ou C++.
; argumento, colocamos um número  | // Não usamos paerênteses suficientes
(my-let-1 (1 5) 1)                | #define SQUARE(X) X*X
                                  | 
; A tradução ficaria:             | // A expressão:
((λ (1) 1) 5)                     | SQUARE(2+2);
                                  | 
; O erro, porém seria:            | // Seria traduzida em:
    lambda: not an identifier,    | 2+2*2+2
    identifier with default, or   | 
    keyword in: 1                 | // O resultado 8 é diferente de 16

SYNTAX-CASE
=============

Poderemos usar,agora, o SYNTAX-CASE, mais geral, para que façamos
regras válidas.

Ele receberá uma lista de pares [A, B], com:
* A, o padrão a ser identificado na linguagem;
* B, cujo VALOR INTERPRETADO será associado a A;

O fato dele associar o VALOR INTERPRETADO da expressão B pode ser 
ruim, caso queiramos apenas devolver uma expressão. Para isso, usaremos
um truque relacionado ao operador #' (à frente).

; Associamos o nome 'my-let-3' a um símbolo x. O 'x' é um auxiliar, 
; que permite chamar RECURSIVAMENTE a estrutura do define-syntax.
; Isso é importante porque o símbolo "my-let-3" poderia ser utilizado
; dentro do pattern ou valor. Temos, então, este auxiliar.
(define-syntax (my-let-3 x)
    
    ; O 'x' de acima é passado para o syntax-case, como um 'this'.
    (syntax-case x ()
        [
         ; Padrão a ser identificado
         (my-let-3 (var val) body) 
         
         ; O símbolo #' serve para que o syntax-case devolva a 
         ; própria expressão, e não o resultado da execução dela.
         ; Em geral, para não executarmos, usamos apenas '. Porém,
         ; ' transforma uma expressão em s-expression. O syntax-case
         ; EXIGE que o argumento seja um PEDAÇO DE SINTAXE - e o
         ; operador #' é o que evita a execução e devolve um pedaço
         ; de sintaxe. O #' será necessário em todos os casos em que
         ; quisermos usar um pedaço do pattern, sem executá-lo (o que
         ; seria, inclusive, impossível, pois ele não existe ainda
         ; dentro da macro).
         #'((lambda (var) body) val)
        ]
))

O my-let-3 faz exatamente o mesmo que o my-let-2, mas usa o syntax-case.
Entretanto, o syntax-case tem uma segunda forma que pode ser útil.
Ele não receberá mais pares [A B], em que associa-se o padrão A 
ao valor (B). Teremos como argumentos trincas [A P B], com:
* A, o padrão;
* B, cujo valor interpretado será associado a A;
* P (predicado), as RESTRIÇõES a serem avaliadas.

(define-syntax (my-let-4 x)
    (syntax-case x ()
        [
         ; Padrão a ser identificado 
         (my-let-4 (var val) body) 
        
         ; Predicado a ser avaliado
         ; Se 'var' não for identificador, dará erro.
         (identifier? #'var)
         
         ; Igual ao caso do my-let-3
         #'((lambda (var) body) val)
        ]
))

SYNTAX-CASE RECURSIVO
=======================

Vejamos um exemplo de syntax-case RECURSIVO. Para isso, vamos
implementar uma forma de OR usando IF's recursivamente:

(define-syntax (my-or-1 x)
  (syntax-case x ()
    ; Usamos um template variádico
    [(my-or-1 e0 e1 ...)
      #'(if e0
            e0
            (my-or-1 e1 ...))
            ; Reusamos o template variádico com menos 1 argumento.
            ; Como a lista é finita, uma hora a recursão para.
))

Esse comando dá um erro, porque no final não teremos mais como expandir
o my-or-1. Consideremos o exemplo:
                            (my-or-1 #f #t)

O resultado da expansão seria:
(if #f #f (my-or-1 #t))
           ^^^^^^^-- (if #t #t (my-or-1))
                                ^^^^^^^-- Sem argumentos, é desconhecido

Precisamos adicionar uma nova regra ao syntax-case, para quando ele 
tem 0 argumentos.

(define-syntax (my-or-2 x)
  (syntax-case x ()
    [(my-or-2) 
      #'#f]
    [(my-or-2 e0 e1 ...)
      #'(if e0
            e0
            (my-or-2 e1 ...))
))

Poderíamos adicionar um passo a mais, com apenas um argumento. O
anterior já funciona, mas poderíamos adicionar um caso extra: apenas
um argumento, em que o devolvemos.

(define-syntax (my-or-3 x)
  (syntax-case x ()
    [(my-or-3) 
      #'#f]
    [(my-or-3 e0) 
      #'e0]
    [(my-or-3 e0 e1 ...)
      #'(if e0
            e0
            (my-or-3 e1 ...))
))

Nesse caso, naturalmente, nunca entraremos no caso base my-or-3 vazio.
Poderíamos retirá-lo, para dar erro de sintaxe, OU devolver falso nos
casos errados.

Consideremos agora o seguinte exemplo:
(let ([blah #f])
(my-or-3
    (begin ((set! blah (not blah)) blah)
    #f)
)

O resultado expandido será:
(if (begin ((set! blah (not blah)) blah))
    (begin ((set! blah (not blah)) blah))
    (my-or-4 #f))

O valor devolvido seria #f (errado!).

Estamos DUPLICANDO código. Esse é um dos grandes problemas de macros:
replicação desnecessária. E isso ocorre por causa do excesso de lazyness
do código.

Para resolvermos, podemos calcular primeiro, e associar o valor
calculado a um símbolo:

(define-syntax (my-or-4 x)
  (syntax-case x ()
    [(my-or-4) 
      #'#f]
    [(my-or-4 e0) 
      #'e0]
    [(my-or-4 e0 e1 ...)
      #(let ([v e0])
        '(if e0
             e0
             (my-or-4 e1 ...))
))

Ainda assim, temos dois potenciais problemas:
* O cálculo do primeiro e0 poderia causar uma mudança de estado - e esta
  não seria passada para o corpo do if. A mudança de estado já estaria
  feita antes, e o resultado poderia ser diferente. Uma outra
  consequência da passagem de estado. O caso do begin acima não era o
  desejado. Porém, se ele fosse, não seria coberto.

* O e0 poderia estar em um environment diferente, e o seu valor estaria
  de forma diferente. Por exemplo:
    
    (let ([e0 #t]) (my-or-4 #f e0))
    
    A expansão seria:
    (let ([v #f])
        if(#f) #f
            (my-or-4 #f))
    
    Nesse caso, estamos CONFUNDINDO o environment externo com o
    environment interno. O valor de e0 usado acaba sendo o de dentro,
    e não o passado de fora.
    
    Bons sistemas de macro não confundem isso, pois usam tabelas
    separadas para valores de argumentos e definições internas de
    símbolos. Essas são chamadas as MACROS HIGIÊNICAS.

=================================================================

MACROS
========

Na aula passada, vimos uma "confusão" dos macros por causa do
environment. A diferenciação entre ambos pode ser desejável, para que
possamos fazer definições de macros RECURSIVAS ou com AUTORREFERÊNCIA.

Os macros que evitam esse problema é um MACRO HIGIÊNICO, mas teria esse 
novo problema. A implementação que daria este problema seria:

; Definição de um objeto com autorreferência
; usando a criação via macros.
(define os-1
    (object/self-1
        
        ; Este self dará um ERRO. O processador de macros do Racket
        ; é higiênico. Logo, dentro do macro ele olhará se esse self
        ; foi definido NESTE AMBIENTE. Ele não foi: logo, aparecerá o
        ; erro do self não ser definido.
        [first  (x) (msg self 'second (+ x 1))]
        
        [second (x) (+ x 1)]
))

; Como fazemos isso com macros agora?
(define-syntax object/self-1
  (syntax-rules ()
    [(object [mtd-name (var) val] ...)
        
      ; Primeiro, associamos self com um símbolo qualquer. 
      ; No caso, é um lambda que imprime que está vazio.
      (let ([self (lambda (msg-name)
                    (lambda (x) (error 'object "nothing here")))])
          
          ; Reassocia self com o lambda seletor dos métodos
          (begin 
            (set! self
              (lambda (msg)
                (case msg
                  ; O macro cria, um lambda usando o nome do
                  ; método, a variável do lambda e o corpo.
                  ; Como pode haver vários métodos, estamos 
                  ; fazendo de forma recursiva
                  [(mtd-name) (lambda (var) val)]
                  ...)))
          self)
      ) ;end let
]))

; O resultado do código expandido seria:
(let ([self 'dummy])
  (begin 
    (set! self
      (λ (msg)
        (case msg
          [(first  (λ (x) (msg self)) )]
          [(second (λ (x) (+ x 1))    )]
)))))

Para contornarmos esse problema, poderíamos passar o 'self' como
argumento para a macro. Dessa maneira, o símbolo ao ser usado dentro
do contexto do uso da macro, quando ela for setada.

; Por que esse self não dá problemas quando passado como argumento?
(define os-2
    (object/self-2 self ; O nome do próprio argumento deve ser passado
                        ; como primeiro parâmetro.
        [first  (x) (msg self 'second (+ x 1))]
        [second (x) (+ x 1)]
))

(define-syntax object/self-2
  (syntax-rules ()
    [(object self [mtd-name (var) val] ...)
        
      ; Primeiro, associamos self com um símbolo qualquer. 
      ; No caso, é um lambda que imprime que está vazio.
      (let ([self (lambda (msg-name)
                    (lambda (x) (error 'object "nothing here")))])
          
          ; Reassocia self com o lambda seletor dos métodos. Agora,
          ; este é o self externo, e estamos afetando a tabela dos 
          ; argumentos.
          (begin 
            (set! self
              (lambda (msg)
                (case msg
                  [(mtd-name) (lambda (var) val)]
                  ...)))
          self)
      ) ;end let
]))

Mas nem sempre seria desejável passar 'self' como argumento. Como evitar
isso? Poderíamos usar um recurso adicional, suportado pelo Racket, que
permite associar um símbolo DENTRO DA SINTAXE com um DE FORA DA SINTAXE.
Dessa maneira, uma mudança de estado dentro da macro altera o espaço das 
variáveis passadas como argumento para a macro. Assim, conseguiríamos
sobrescrever o self (o que não acontecia na 1ª forma, pois o self estava
em outra tabela de símbolos).

(define os-3
    (object/self-3
        [first  (x) (msg self 'second (+ x 1))]
        [second (x) (+ x 1)]
))

(define-syntax object/self-3
  (syntax-case ()
    [(object [mtd-name (var) val] ...)
      (with-syntax ([self (datum->syntax x 'self)])
        #'(let ([self (lambda (msg-name)
                        (lambda (x) (error 'object "nothing here")))])
            (begin 
              (set! self
                (lambda (msg-name)
                  (case msg-name
                    [(mtd-name) (lambda (var) val)]
                    ...
              )))
              self
            )
          ) ; let
      ) ; with-syntax
    ] ; definição de objeto
))

=================================================================

ESTRUTURA CLIENTE SERVIDOR
============================

(define (read-number [prompt : string]) : number
    (begin
        (display prompt)             ; Mostra o prompt
        (let ([v (read)])            ; Lê da stdin e associa a v
            (if (s-exp-number? v)    ; Testa se é número
                (s-exp->number v)    ; Converte para número
                (read-number prompt) ; Se não funcionar, lê outro
                                     ; número
))))

(display 
    (+ (read-number "Fist number")
       (read-number "Second number"))
)

Se estivéssemos numa arquitetura cliente-servidor, este programa simples
de somar NÃO FUNCIONARIA. Você pediria o programa, o servidor enviaria a
pergunta "First number" e, então, acabaria a conexão.

CLIENTE-SERVIDOR COM MEMÓRIA
------------------------------

Precisamos quebrar o programa em DUAS PARTES: o primeiro pedido do
número (requisição 1), e depois executar o pedido do segundo número
(requisição 2). Até termos o segundo número, precisamos GUARDAR o 
primeiro deles.

Uma função que quebrasse poderia ser:

(lambda (v1)
  (display
    (+ v1
      (read-number "Second number")
)))

Guardamos v1 no environment do lambda e depois esperamos pelo segundo
número aparecer.

CLIENTE-SERVIDOR SEM MEMÓRIA
------------------------------

Mas essa solução usa memória. Se tivéssemos vários usuários, poderíamos
ter muitos dados armazenados. No pior caso, isso se tornaria um ataque
DDoS (Denial of Service), pois exauriríamos o recurso do servidor.

Uma boa solução para contornarmos isso será criar uma ação que se
interrompe, enquanto aguarda pelas respostas dos usuários. Para cada
solicitação teremos um id único. Enviamos para o usuário um formulário
que contém o id da ação a ser realizada. Quando ele enviar os dados, o 
servidor executará a ação.

; Como usaremos o hacket na maior parte de seus recursos, usaremos 
; a feature de criar um HASH para manter a tabela de símbolos de 
; ID_REQUISIÇÃO → PROGRAMA

; O label para os processos serão números. 
; A tabela será um hash vazio.
(define-type-alias label number)
(define table (make-hash empty))

; A função read-number/suspend apenas pega uma ação "rest" e a
; carrega na tabela de requisições.
(define (read-number/suspend [prompt : string] rest)
  
  ; New label é uma simples função contadora
  (let ([g (new-label)])
    (begin
      (hash-set! table g rest)
      (display prompt)
      (display " To enter it, use the action field label ")
      (display g)
)))

; Esta ação é a "resposta", que envia o dado solicitado para o servidor.
; Na analogia web, esta seria uma página com FORMULÁRIO, a ser submetido
; ao servidor. Na resposta, teríamos o ACTION-FIELD, o label do hash que
; marca ONDE ESTÁ A AÇÃO A SER EXECUTADA.
(define (resume [f : label] [n : number])
  ((sum-v (hash-ref table g)) n)
)

; A ação usando o read-number com suspensão fica:
(read-number/suspend 
  "First number"
  (lambda (v1)
     (display
       (+ v1
         (read-number "Second number"))))
)

; Para um esquema cliente-servidor mais robusto (no caso, que lesse os 
; dois números via este sistema), precisaíamos usar duas solicitações.

A representação das solicitações ficaria:

            Servidor             |              Cliente
=================================|====================================
                                 |            
   . read-number/interrupt  -----:----- label: 05
   :                             |      form: Mande valor
   :                             |            
   :   table                     |      resume 05 42
   : .----.--------------.       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   : |    |              |       |           |
   '>| 05 | rest         | <-----:-----------'
     |    |  |           |       |            
     |    |  |           |       |            
     '----'--|-----------'       |            
             ^                   |
         read-number             |

ESQUEMA CLIENTE-SERVIDOR COMPLETO
-----------------------------------

Há um problema: o lambda solicitando o v2 pede no servidor (o que não
é realista). Para resolver, basta colocarmos uma solicitação dentro da
outra:

(read-number/suspend 
  "First number"
  (lambda (v1)
    (read-number/suspend 
      "Second number"
        (lambda (v2)
          (display
            (+ v1 v2)
)))))

            Servidor             |              Cliente
=================================|====================================
                                 |            
 ..- read-number/interrupt  -----:----- label: 05
 : .-'                 ^    |    |      form: Mande valor
 : :                   |    |    |            
 : :   table           |    |    |      resume 05 42
 : : .----.------------|-.  |    |           |
 : : |    |            | |  |    |           |
 : : |    |  sum       | |  '----:-----------:------ resume 03 0
 : : |    |   ^        | |       |           |            |
 : '>| 03 | rest2      | | <-----:-----------:------------'
 :   |    |            | |       |           |
 '-->| 05 | rest1 -----' | <-----:-----------'
     |    |              |       |            
     |    |              |       |            
     '----'--------------'       |            
                                 |
